{"title": "小程序中设置缓存过期 ", "author": "Rolan", "time": "2020-1-15 00:23", "content": "需求是两张图片在这个时间段内交替显示，当天只弹一次图片。后端返回的数据格式：中缓存没有过期时间，也就是说存储进去的缓存要自己手动清除，那么如何保证两张图片能够交替显示呢？这里有个关键是，如何知道时间有没有到第二天？需要用到两个缓存：为什么要用到两个？因为这里有两个状态检测：一个是否在有效期内，一个是当天是否弹过弹窗。如何判断时间有没有到第二天？将所有天数的时间戳加上一天保存起来（ps：这个方法很蠢）。然后每次进入小程序都获取下当前的时间，对比下当天的时间是否大于保存的时间戳。如果超过就说明已经到了第二天。为什么要加上一天？因为后端返的开始时间是当天的凌晨，而真正要过完这一天是24点之后。一天的毫秒数：。声明需要使用的时间戳声明需要一共多少天，以及当天是第几天；这里使用向上取整判断当前时间是否在时间有效期内内，如果在时间有效期内，就弹弹窗，如果不在就不弹接下来开始写弹出弹窗的逻辑。首先判断当天的时间戳是否大于前一天的时间戳，如果大于就说明到第二天了，如果小于说明今天还没有过去。然后清除前一天的缓存图片交替显示检查当天广告是否弹出过弹出广告，并设置缓存一进入页面读下本地缓存，是否要弹出弹窗。这里最大的问题是如何判断当前的时间有没有过点，自己一直没有想到比较好的解决方法，限于自己的水平，没有更好的方案，这里我只是记录下实现的过程，不喜勿喷，如果有更好的方案，欢迎指点。另外可添加微信交流"}
{"title": "小程序中解决网络请求缓存 ", "author": "Rolan", "time": "2019-12-30 00:45", "content": "提交审核时，有一个体验测评，产品让我们根据小程序的体验测评报告去优化小程序。其中有一项是网络请求的优化，给我们出了很大的难题。文档中是这样解释的：3分钟以内同一个请求不出现两次回包大于且一模一样的内容看到这个问题的时候，首先想到的是在响应头上加上，经过测试发现小程序并不支持网路请求缓存。搜索发现官方明确答复，小程序不支持网络请求缓存：既然官方不支持网络请求缓存，那只能自己想办法解决这个问题了。先来看一下需求：分析：前两点比较好实现，虽然小程序不支持网络请求缓存，但我们还是可以利用来实现这个功能。首先网络请求需不需要情缓存统一交给服务端去做，服务端在处理请求时，统一加上响应头，如果需要缓存就用，如果不需要做网络请求就用。前端根据响应头信息自己做前端缓存。其中的难点是前端如何知道服务端数据有没更新，如果服务端数据更新了，前端还是使用缓存这是有问题的。经过一番思考后发现，前端提交数据后，相应的请求数据会更新，也就是说前端只要有数据提交，就应该把缓存清空。这有一个难点，当前端提交数据时，前端是不知道哪些请求会因此更新数据，所以这个问题我们没有解决，我的方法比较粗暴：只要前端提交了数据，就将所有缓存清空。这是一个治标不治本的问题。公司项目封装了请求有一点没有说，就是这个缓存是保存在哪里的？既没有用，也没有用，用的是类的静态属性。这样做有个好处：我在使用时遇到一个坑，是因为自己没有理解：最后，此方法还是有很大的优化空间。另外可添加微信交流"}
{"title": "小程序初实践总结 ", "author": "Rolan", "time": "2019-12-31 00:05", "content": "近期组内接了项目，也是有幸能够加入到项目中，做一些简单的开发。之前对小程序有所接触，但是仅限于自己了解和书写demo，真正项目开发还是第一次~开发过程中也是遇到了一些不熟悉和自己觉得是小坑的地方，做个简单总结，给自己做个记录，同时给需要的小伙伴一些小小参考。答：这个问题开始是很迷茫的，仔细检查了文件名称、引用路径以及父组件usingComponents，都没有发现有问题，但是控制台依旧提示找不到对应组件。后面经过大老提示： 对于一个新的组件，必须在对应的js里添加Component({})，json文件里也要写上component:true。加上相关配置后，控制台就不会飘红了。答：使用text组件展示文字内容，看上去并没有什么技术而言，直接引用就好了（心里默默开森）但是，看到效果之后，显然有点蒙圈，为什么上边会出现那么大的距离啊？！第一个想法是去看css，是否有默认内边距样式，然而并没有；通过padding、margin去设置值，也没什么用；然后。。然后。。。我就不知道怎么办了，只好请教度娘。网上有小伙伴给出了答案，其实并不是样式问题，而是text组件本身问题，要修改这个问题，只需要把text标签和内容写在一行就可以了。答：众所周知，小程序是可以进行分享的，有两种方式，一个是自带的分享功能，另一个是页面上按钮点击分享。本质上他们调用的是同一个方法，即onShareAppMessage，可以通过options参数的options.from区分是来自按钮还是原生分享，可以通过设置对应字段修改分享展示的内容，不设置则默认分享当前页。按钮分享，只需要给button添加一个open-type即可，<button open-type=\"share\"></button>。但是此时按钮会有默认样式，可以通过控制台查看，进行css修复样式，分享回调同样调用上边方法。答：实际开发中，我们基本会遇到需要获取某个元素位置信息的需求，早在jq一把梭的时代，获取这些属性值是很容易的，直接一个api就可以了。同样的小程序里也有比较实用的方法，我们可以给需要获取位置的元素/组件一个id，然后通过下面方法即可获取：如果在页面初始化时需要获取到位置，可以在onLoad方法里使用（最好使用setTimeout，否则可能会取不到），获取对应值之后就可以进行后续的处理了。答：滚动组件的使用，在开发中可以说很普遍了。小程序也封装了scroll-view组件，并提供了一些封装好的方法，使用起来可以说很方便了，但是也不可避免的有一些需要注意的地方。当页面组件按照文档方法书写完成后，去滚动页面发现页面滚动事件并没有触发，后面经过仔细查看，确定问题原因是scroll-view没有设置高度，而且必须是精准高度，不能用百分比。我们开发时可能需要用到点击后滚动到某一位置或者初始化时滚动到对应位置，过去通常是通过锚点方式进行触发，同样的scroll-view为我们封装了一个很好用的方法scroll-into-view，对应的值也是一个id值，具体使用方法及注意事项可以参考文档（）。这个问题算是比较坑了，在scroll-view里面，我们设置某个元素或者组件为fixed定位，在滚动页面时，会发现定位的元素会消失一下然后再出现，虽然不是什么严重问题，但是很影响用户体验。这个问题我看到社区里也有很多人在问，但是目前官方还没有给出合理方法。目前简单的应对方法我总结了两点：一是把定位元素放到scroll-view外部，此类方法可以完美避开上述问题，但是某些场景下可能不太适用；二是，在使用scroll-view时我们通常会设置scroll-with-animation=true即开启滚动过度动画效果，当我们把这个值设置为false时，上述问题也能很好的解决，即使定位元素在scroll-view内部也不会有闪现问题。但是此方法牺牲的也是用户体验，如果有短距离的页面滚动可以使用此类方法。欢迎遇到此类问题的小伙伴进行补充，在官方给出完美方案之前，我们也能有自己的应对方案。这个就不得不吐槽一下UI了，其他的都还好，但是对于表单相对应的样式，真的是丑爆了！而且，当你想通过css样式覆盖方法修改的时候，会发现，你的修改根本就是不起作用的！！根本原因就是你所看见的wxml结构与内容和样式所定义的根本不是一个样子！！！当然也有机智的小伙伴探究出了方案（以checkbox为例）：当然，如果你不喜欢原组件，不想去修改css，完全可以自己仿写一个checkbox，样式自己写，切换效果通过点击事件（参数e，获取data）自己控制就好。关于表单内容，后面会再总结一个自定义表单及自定义校验方法及自己进行的优化。小程序页面跳转，我们可以通过wx.navigateTo()方法进行，但是当需要跳转到不同域页面时，直接跳转链接的方式就不好用了。小程序也为我们提供了方法，即webb-view()。以上就是在初次开发中遇到的问题及总结的使用方法，后面随着使用的增多，肯定还会有更多的问题出现，随时进行添加吧，算是对小程序使用自己的一个总结，有不足和错误之处，还希望各位大大提出宝贵意见。ps：前期初次接触小程序书写demo时，也遇到了一些小问题，付个传送门："}
{"title": "如何一人五天开发完复杂小程序（前端必看） ", "author": "Rolan", "time": "2019-12-31 00:21", "content": "随着业务需求的不断累加、追求快速产出。在人手不足且开发周期较短的情况下，我们需要找到一个最大化开发效率的方法。而高效率的开发离不开规范化、工程化、组件化。为此整理写下总结，细数小程序中的坑与实践。介绍我们对小程序高效率开发的思考与探索。布局方案导航栏TabBarBasicPage用户系统登录方案初始化登录鉴权优化及 Bug 追踪日志收集数据分析常用优化方案preLoad独立分包加载我们首先思考的是，在小程序中如何快速且高还原产出页面。为此我们封装了一套页面组件。目前小程序有如下两种导航栏：常规、自定义导航栏自定义导航栏布局下，我们可以完全控制导航栏样式，赋予导航栏更多交互及 UI 设计上的可能。如上图所示，Readhub 在导航栏中加入了设置按钮，喜茶在个人页中标题渐隐及沉浸式导航栏效果。常规布局下，顶部导航栏部分直接使用小程序提供导航栏。可根据具体业务选择具体布局方案，在我们小程序中，我们选择了全部使用自定义导航栏的方式并对其进行了一定封装。在确定使用自定义导航栏方案后，我们对导航栏进行了拆解拆解后，我们发现可以将自定义导航栏分为两个部分：StatusBar 及 NavigationBar 。通过查阅微信 API ，我们分别通过及获取到 StatusBarHeight 及 MenuButton 的布局信息。由拆解图可知得到上述数据后，结果简单封装， 我们得到如下方案StatusBar 部分， 我们使用 PaddingTop 填充。可在此基础上可再进一步封装一些通用 NavigationBar 组件。我们封装了一些常用 NavigationBar 组件， 如下所示：目前小程序 TabBar 中也存在两种方案。常规 TabBar ：微信提供方案，可修改 icon 、 文字及其对应选中状态。自定义 TabBar ：小程序基础库 2.5.0 开始支持。可通过其实现异形 TabBar 或各种自定义样式。在我们小程序中，我们选择全部使用自定义 TabBar 来实现业务。由于小程序基础库 2.5.0 之后官方才开始支持自定义 TabBar 。我们此处不直接选择使用 custom-tab-bar 方案。选择结合 custom-tab-bar 、 自定义组件及的方案实现。具体方案为放置空节点 custom-tab-bar 文件。在页面中按需引入自定义 TabBar 组件。在页面初始化完成后调用隐藏原 TabBar 。这样做的好处在于，在基础库 2.5.0 及更高版本时正常显示，在低版本时以最小代价兼容。在 iPhone X 系列下的底部安全区兼容方案如下推荐如无特殊需求，建议直接使用微信提供方案，在自定义 TabBar 方案中 安卓手机下拉刷新时， TabBar 会被拉出可视区域。需自定义下拉刷新组件解决以上方案在线上运行一段时间后稳定后。对自定义导航栏及自定义 TabBar 方案进行了整合。封装了 BasicPage 组件。以我们线上典型页面为例，我们可以将页面分为两大类。基于以上分析结合线上需求，我们对此基础组件进行封装。Taro 框架伪代码，可根据各自使用框架进行封装，思路一致使用中会经常用到 自定义 TabBar 、 自定义 NavigationBar 布局数据。再封装一个工具类获取。到此，我们完成对基础页面组件的封装。目前线上运行小程序所有页面都基于该组件进行开发。开发新页面时只需要引用该组件即可。在一个应用中，用户系统是至关重要的。我们通过数个小程序的开发，整理了一套我们目前正在使用的用户系统实践。如上图所示，我们将小程序登录及获取用户信息拆分为两部分。主要有如下考虑：降低用户使用门槛，可先让用户体验部分功能。后续分享或互动时提示授权完善用户信息保证始终持有用户登录态，方便程序处理。如把用户登录及完善用户信息放置一起，在未授权时无法获取自定义登录态。判断变得复杂且无法提前收集 formId同一开发者账号下，多小程序互通时，如有一小程序用户授权过，可通过返回 unionid 直接同步信息，无需再授权，提升用户体验。授权获取用户信息时，如果服务端未记录用户 sessionKey ，在 Button type = getUserInfo 回调事件中使用方法获取 code 的话，会导致 sessionKey 变化。从而导致 getUserInfo 时使用 sessionKey 与新 sessionKey 不匹配。从而导致解密用户信息失败。解决方案有如下两种：Button type = getUserInfo 回调事件中使用方法后，再次调用方法重新获取加密用户信息。服务端记录 sessionKey ，Button type = getUserInfo 回调后无需调用，直接提交供服务端处理。第一种方案适合简单改造旧项目、快速开发，但强烈建议使用服务端处理方式解决。完善用户信息时，解密用户信息部分请查看官方文档，这里不叙述具体流程https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/signature.html另外，在登录流程中服务端向微信换取 sessionKey 过程中，如果满足一定条件，会直接返回 unionid 。同开发者账号下多个小程序时可用 unionid 做用户信息同步，无需再授权。提升用户体验。unionid 机制: https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/union-id.html在日常开发中，我们通常会把登录获取 token 操作放置在小程序初始化中即 app.js 定义的中。而该生命周期与页面初始化生命周期为同步进行。此时，如果在页面初始化中，需要携带用户登录态请求接口获取信息时，可能出现如下情况因为小程序初始化及页面初始化是同步进行的。若页面初始化时，小程序初始化中登录请求仍未完成。会导致未携带 token 或其他鉴权信息，鉴权失败。最开始我们通过在组件中挂载一个特殊事件，待小程序初始化登录请求后获取当前页面实例进行调用。但该方案对代码侵入性太强，最终我们选择维护一个登录请求队列。用上队列的原因在于，在产品需求上经常会有先跳入首页，再从首页跳入二级页的需求，这样能让用户回退一次后，仍然能回到首页。但会导致在不同页面中近乎同时调用方法。在第一种方案中，解决该问题需要获得所有页面实例进行调用。而引入队列后只需要轮询消费队列中函数执行即可。上述流程可解决此问题。伪代码如下：代码仅供理解思路业务需求中，通常存在某些操作需要 【 用户授权完善信息 】 后才能继续进行，早期项目中都是各自页面中写鉴权代码。因而会涉及大量重复代码，也不利于快速开发。为此我们封装了一套鉴权方案。通过所有页面基础一个基类 BasePage 。在 BasePage 中写入鉴权逻辑来实现。配合在主页面中使用 AuthorizationModal 组件实现鉴权。代码仅供理解思路页面继承该基类在页面中置入组件接下来，我们只需要在需要鉴权的操作中如下使用即可该方案好处在于，授权由状态驱动，只需在代码中调用 checkAuthorization 方法即可。后来，由于第一种方案过于重，对页面代码侵入性较强。为此我们又封装了一套较轻的组件。大部分逻辑中，需要用户主动点击时才进行鉴权，我们基于此思路封装了 AuthorizationView 。对外暴露 onAgree 、 onDeny 方法实现对部分区域的点击鉴权操作。代码仅供理解思路代码中只需要使用该组件包裹子组件即可使用以上两种方案都有在线上业务中使用，具体选型看业务决定在维护阶段，我们会更加关注于用户反馈 bug 时如何复现场景及数据分析。在小程序基础库版本 2.1.0 后，微信提供了一套日志相关接口：LogManager 。在用户反馈时，通过该接口记录的日志会同步上传至微信后台，可下载查看追踪 Bug。我们通过简单的对其封装，实现一套日志收集机制。"}
{"title": "小程序wifi能力解读与实践 ", "author": "Rolan", "time": "2020-1-3 00:28", "content": "wifi系列接口为系统原生能力。早在2015年，微信就推出了「微信连Wi-Fi」，微信连Wi-Fi是为商家的线下场所提供一套完整和便捷的微信连Wi-Fi的方案。现在已经是一套完整的，便捷的解决方案。顾客通过扫码的方式连接wifi，同时微信还可以向用户下发消息。方案在官方文档已经阐述得很详细，本文就不再赘述。本文重点在于讲解小程序中使用wifi能力遇到的问题和心得。在小程序中，使用wifi模块都需要先调用来初始化wifi模块。以下能力的使用均需要在的回调中使用。为我们提供了直连wifi的能力， 仅 Android 与 iOS 11 以上版本支持，需要基础库1.6.0以上。这个一般是我们使用wifi功能的核心API了。在ios中，会出现系统弹框，询问用户是否要连接wifi，只有用户点击确定，才会继续进行，否则就走fail回调了。在安卓（以小米note3为例，Anroid9）中则会出现的toast。从社区中获取的信息得知：表示信号强度，iOS 是系统返回的，取值 0-1，安卓经过转换，取值 0-100。数值与信号强度为正比例关系。获取周围的wifi列表，需要先使用后使用进行监听。，这是由于ios系统的限制， 目前是无法避免的（其实这么做也无可厚非，wifi信息本来就是敏感的，但是对用户体验有一定的影响）。，因为可以利用小程序嗅探周边Wi-Fi热点来推断用户所在的位置信息。为了确保用户的隐私不受侵犯，自微信android客户端 7.0.4 起，需要先获取用户地理位置（scope.userLocation）。详情请见连接指定 Wi-Fi 接口调用时序：连周边 Wi-Fi 接口调用时序：连接指定 Wi-Fi 接口调用时序：(与安卓一致)连周边 Wi-Fi 接口调用时序：笔者在项目中接触到了使用小程序提供的硬件（wifi）能力的场景。利用wifi与socket的能力，我们可以为物联网设备连接wifi。流程如下:wx.request/wx.connectSocket/wx.uploadFile/wx.downloadFile 的 url 参数允许为{PORT}/${PATH} 的格式，当且仅当 IP 与手机 IP 处在同一网段且不与本机 IP 相同（一般来说，就是同一局域网，如连接在同一个 wifi 下）时，请求/连接才会成功。\r\n在这种情况下，不会进行安全域的校验，不要求必须使用 https/wss，也可以使用 http/ws。局域网通信中，不会进行安全域校验，因此，无需在mp后台添加安全域域名。借助小程序提供的硬件能力(wifi,蓝牙，NFC)，小程序有了更加广阔的场景。比如【摩拜单车】小程序，有的车需要用户开一下蓝牙，小程序提供的操作原生系统的蓝牙功能便为我们赋能。通过小程序，我们也可以实现与物联网设备通信，通过连接设备热点，利用http/wss/udp传输数据。当然，现在wifi能力还是存在着问题，比如兼容问题，可能有部分安卓手机在连接时会莫名其妙的报错。此时需要对着官方提供的errcode查看具体的原因。"}
{"title": "探索小程序实现 ", "author": "Rolan", "time": "2020-1-6 00:15", "content": "随着的发展与功能的逐步完善，越来越多的产品需要小程序与 APP 的功能能有一些共性，社区跨平台的解决方案越来越多，比如 taro 等为代表的把一套代码编译成多端运行的机制，本文会使用 Swift 作为原生语言，在 iOS 应用上运行一个小程序 Demo， 使用 Android && React Native 也可以采用同样的思路实现。相关代码仓库：编译的目的是为了抹平小程序的与 H5 的差异，利用 Vue 实现数据绑定，利用 Web Component 实现小程序的组件功能。从官网文档中可以看出来，运行一个小程序需要框架（数据绑定渲染）、组件（小程序渲染单元）、api（与原始交互的能力）。把所有页面打包成一个 js， 再由 js 管理所有的路由和状态，这种方案适合在 web 端运行，并且是单引擎的方案，在模拟原生的右滑返回等效果也会不尽人意。众所周知，小程序是一个双引擎的框架，上面的方案显然不能达到要求, 双引擎的特点是在运行 javascript 的黑盒子中，无法访问到 DOM && BOM 等。将所有的逻辑代码在原生的 JavascriptCore 中运行，WebView 中的 Javascript 引擎负责数据绑定，需要解决的难点是 JavascriptCore 中的 setData 怎么通知 WebView 渲染， WebView 的事件怎么执行 JavascriptCore，接着往下看。wxml 是一种类 html 标记语言，他负责所有的渲染规则，包括条件渲染、列表渲染、数据绑定等，与其再实现一种框架，还不如直接利用 Vue 实现同样的功能，再利用各种转换库将 wxml 中的事件转换成 Vue 能够识别的事件，如利用可以做到如下的转换:每一个事件绑定的方法全都在原生的 JSContext 中运行，所以此时的事件只需要传递给 JSContext 的作用。wxss 作为小程序的样式语言，其余 css 的主要区别就是多了一个 rpx 单位，以下是官网的换算表：根据上表可得知，;在传统的移动端页面，我们的高清方案，一般需要获取 dpr， 然后修改动态修改 viewport 和 html 上的 font-size，但是小程序的代码因为是放在了设备本地，所以可以在下载小程序页面之后，我们还有一次编译机会，这时就可以把 rpx 根据当前设备的屏幕宽度替换成对应的 px。还有一个，则利用 scss 或 less 就可以合并到同一个 css 文件中,而全局样式则可以在构建 WXML 的时候再植入进入组件具有独特的功能和自己的渲染规则，比如具有和等属性控制滚动条。在 HTML5 中有一个重大的功能，它能够自定义 html 元素，并且能够监控属性的变化，非常适合实现小程序组件。如：（使用了框架）这里用了 lit-element 这个框架，能够简化一些操作。App 负责整个应用的生命周期以及存一些全局的数据，能获取到 app 的信息。 所以类似的结构可能是这样的：能够直接访问到内部对象，并且在最顶层声明，这样每一个的地方都能访问到。初始化一个页面都需要是实例化 PageClass, 即使再次进入（不是返回到这个页面）这个页面页需要再次重新实例化，每次实例化都需要关联一个 webviewId, 这个 ID 与原始的 webview 关联，这样每个 PageClass 中的 setData 都能找到对应的 webview 进行再次渲染，所以对应的代码可能是这样的：通过 API 能够直接调用原生的功能，比如， 如果直接在 webview 中的 JSContext 中运行的话，则可能存在跨域，但是放在原生就不会存在这个问题。实现JSContext 调用原生代码的功能，需要给 JSContext 中植入一个 JSBridge，如：和, invoke 负责同步任务，on 负责异步任务，原生再利用反射（原生的反射真麻烦）调用对应的原生方法，原生可以利用挂起 JSContext，既可以达到同步和异步的方法。Javascript 代码打包后被放在 JavascriptCore 中运行，唯一与 Webview 中的 JSContext 打交道的只有, 先看一下打包流程：打包流程及其简单，接下来看一下两个 Javascript 引擎的交互过程。每次进入一个页面的时候都需要为这个页面的 webview 分配一个 id, 这个 id 至关重要，作为 native 与 JSContext (原生运行 javascript 的上下文对象) 与 webview 交互的唯一标识，JSContext 中需要实例化一个新的 PageClass 关联这个 id， native 中通过 id 保留 webview 的引用。在 JSContext 中植入一个 JSBridge 用于与原生交互，如：, 当 JSBridge 的 setData 被调用后，通过 appId + webviewId 就能找到对应的 webview, 再将 setData 传入 webview 中，在 Vue 接收到 data 后进行渲染， 整个过程如图：有了前面的铺垫，接下来再看 webview 如何调用 JSContext 的方法， Webview 唯一能与 JSContext 交互的方式只有事件，事件触发后，需要通过某种方式触发 JSContext 中的方法，最后调用 setData 再返回来重新渲染 webview。webview 中绑定的方法名众多，如：等，但是可以通过 “抹平 WXML” 的时候最终只保留一个出口，如:等，这样 vue 中的 method 只需要实现对应的几个事件便可：利用原生作为桥梁，在两个引擎之间通信，webview 中的 JSContext 负责接收渲染通知，以及发送事件到 Native 的 JSContext 中，JSContext 独立运行，所以既访问不到对象，也访问不到对象。"}
{"title": "小程序摸爬滚打之路 ", "author": "Rolan", "time": "2020-1-10 00:12", "content": "上面这张图相信接触过的开发者多多少少都有看到过，小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本。那么为什么要这样设计呢，为了管控和安全，我们需要阻止开发者使用一些，例如浏览器的window对象，跳转页面、操作DOM、动态执行脚本的开放性接口。我们可以使用客户端系统的 JavaScript 引擎，iOS 下的 JavaScriptCore 框架，安卓下腾讯 x5 内核提供的 JsCore 环境。这个沙箱环境只提供纯 JavaScript 的解释执行环境，没有任何浏览器相关接口。既然小程序的模型是双线程模型，那么是如何实现双线程之间的通信呢，由上图可以看出，逻辑层和视图层是通过Native层来进行转发的，这也就是说，我们可以把 DOM 的更新通过简单的数据通信来实现，类似于虚拟DOM的实现，用JS对象模拟DOM树，然后进行diff,然后把差异在视图层进行渲染，这一系列在Native之间的转化则由小程序的基础库来完成。Exparser是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由Exparser组织管理。当前Web Component已经支持局部作用域、slot插槽等等现有框架所提供的组件化方法，学习Web Component也是我接下来自己学习的目标之一。小程序的视图层目前使用 WebView 作为渲染载体，而逻辑层是由独立的 JavascriptCore 作为运行环境。在架构上，WebView 和 JavascriptCore 都是独立的模块，并不具备数据直接共享的通道。当前，视图层和逻辑层的数据传输，实际上通过两边提供的 evaluateJavascript 所实现。即用户传输的数据，需要将其转换为字符串形式传递，同时把转换后的数据内容拼接成一份 JS 脚本，再通过执行 JS 脚本的形式传递到两边独立环境。而 evaluateJavascript 的执行会受很多方面的影响，数据到达视图层并不是实时的。小程序启动会有两种情况，一种是「冷启动」，一种是「热启动」。假如用户已经打开过某小程序，然后在一定时间内再次打开该小程序，此时无需重新启动，只需将后台状态的小程序切换到前台，这个过程就是热启动；冷启动指的是用户首次打开或小程序被微信主动销毁后再次打开的情况，此时小程序需要重新加载启动。小程序框架自带的网络请求和Ajax请求非常相似都是异步请求，请求参数中需要送入url、method、data、header等参数，还要设置success成功的回调函数和fail失败的回调函数，如下图所示通过回调函数处理就很容易造成回调地狱，所以Promise化还是很有必要的在小程序的日常开发中大家肯定会遇到需要对数据进行过滤转义的场景，而微信小程序没有像Vue一样的filter过滤器功能，大多数人会在渲染之前对数据进行一次清洗，而WXS就是为了解决这一痛点WXS最常见的用处可能就是实现一个过滤器，如下所示"}
{"title": "基于 Angular 的小程序可视化编辑器 —— Panel-Magic ", "author": "Rolan", "time": "2020-1-10 00:41", "content": "是一个基于 AngularX+ 并面向设计师或运营人员的可视化搭建平台，目前仅可用于快速生成微信应用，具有与 Photoshop 相似的交互体验！！好了，吹完之后接下来开始从技术角度剖析其中主要的实现原理在此之前说明该平台的定位，目的不是给技术人员编辑完之后进行二次开发或代码的定制化。关于这个定位问题我个人的想法是，code 问题不可能完全交托给可视化编辑、除非是类似传统的简单的企业介绍页等还有可能完全代替，但还是比不上直接代码生成的工具，所以 Panel-Magic 一开始的定位就是给设计师或运营人员使用，生成的产物不再是 code。关键是中间的数据模型的建模过程以及可视化界面的创建，生成的新数据和源数据都是约定好固定格式的 JSON 描述文件，其包含固定的 key 字段和对应的 value 值类型，生成小程序的过程在生成完新数据之后目前源数据约定的数据格式为更为完整的约定格式在为了实现更好的自由布局排版，绝对定位是我的首选选择，也更能匹配像素级别的定制编辑除了定位数据以外，每个组件其实都具有通用的样式数据，如边框设置、阴影设置、文本设置、定位设置等通用元素，甚至也具有通用的事件设置，然后对于编辑来说，组件同时也具有如选中时的轮廓样式数据等，所以我们定义一个基本组件数据模型，让所有组件都继承这个模型，那就是拿 button 按钮组件举例来说，它位于;其中文件是用于在左侧拖拽组件到中间编辑区域时候的默认样式和事件数据，它是直接实例化了 PanelWidgetModel 并导出其中 component 部分为：然后在渲染的时候双向绑定里面的文本数据对于简单的组件提供的基本数据模型足矣；稍微复杂的组件如地图组件则可以在 component 文件里自行拓展类；有了之后，我们来看看渲染组件的核心代码部分 :point_down:;在模版中异步循环渲染里的组件并传递数据给 app-panel-widget 组件;其中定义为;就是上述提到的 PanelWidgetModel 类列表；而 app-panel-widget 组件位于它负责接收里的每一个不同组件并根据类型负责渲染对应的组件；所以，当你在面板中选中某个组件的时候，不单单只是一个简单的 click 事件组成，是由鼠标的移入、鼠标按下、鼠标弹起等分解步骤来完成；我们先看看事件, 它执行的方法为；这里先补充一下，服务负责管理拖拽时的辅助线计算、轮廓描边生成以及右键事件等核心编辑服务，该服务的就是用于生成组件轮廓数据和拖拽点的数据模型类；所谓'轮廓描述'，就是计算多个或单个组件的最长、最高的描边回到, 这里当鼠标按下的时候并不是直接生成该组件的轮廓描述，而是多了键盘事件的判断，用于按住的时候多选多个组件并将生成的轮廓描边包含出多个组件，如其中生成轮廓的逻辑核心部分在里的方法,:point_down:其中是计算大小和位置的核心更为完整的逻辑在服务里；接下来就是拖拽事件，拖拽的组件并不单单是某个组件，而是轮廓包含在内的所有被选中组件，核心代码在的方法里；注：由于拖拽的过程当中，改变的是每个组件自身的位置信息数据，而轮廓描述是由计算生成的，所有在拖拽的过程当中还需要实时计算主轮廓数据；小结：默认情况下所以依赖于类的组件都可以进行旋转，但就是因为这个旋转角度，所影响的问题包括了拖拽边框拉伸、多选组件一起拉伸、对齐辅助线计算不准确等一系列问题，所以在旋转之后需要计算与不旋转时候的差值增量，具体计算方式可以看我另一篇水文核心函数位于的;具体的边框拉伸计算方式核心都在服务如果只选中一个组件对其进行边框拉伸是很好计算的，即使有个旋转角度也很好的计算，倘若选中的是多个组件一起呢？我的解决方案就是;拖拽边框拉伸改变的其实不是组件本身的边框，而是主轮廓的边框，只是计算一下这个轮廓内部所有被选中的组件相对于轮廓来说的而已核心代码位于;PS:类是类里的用于描述组件本身的轮廓数据类这样一来所有被选中的组件都有了相对于主轮廓来说的位置比例，在进行拉伸计算的时候，将组件自己的宽高和主轮廓的宽高比例保持一致，即可先看看对齐辅助线效果;用过 PS 的蛇鸡丝应该对这个功能不会陌生，我个人也很喜欢这么牛逼的辅助线对齐；我们先看看对齐辅助线渲染的模版文件，它位于；辅助线数据依赖于里的, 其实就是描述主轮廓的可观察类, 定义如下;其中就是包含了对齐辅助线的所有位置数据大致思路就是在点击主轮廓正准备拖拽的时刻，计算好不在主轮廓内的其他外部组件的所有位置数据信息并记录在某个变量里，完了之后在拖拽的过程当中，计算主轮廓的位置信息与这个变量内的数据差值是否达到了临界点，从而决定是否显示对齐辅助线和改变位置；在这个组件下开启对主轮廓的订阅然后拖拽过程中限流的计算位置信息关于前进与后退可以看我另一篇水文;实现原理比较简单粗暴，就是把每一次你认为需要记录下来的操作存一份数据到浏览器的 IndexedDB 里，前进就是在表里面查找最新保存的状态并渲染，后退就是查找上一次状态并渲染我特别喜欢剪贴蒙版部分，在写它的过程当中感觉就像是做了好几道初中数学大题！我们先看看它的效果它的核心其实就是依赖于一个 CSS 的属性而展示出来的几个固定剪贴蒙版本质上就是在计算组件的对应的不同属性值核心文件在整体的搭建从架构方面来说并不复杂，生成的小程序代码包也没那么的神秘，其中花费时间较多的自然就是在处理各种极致交互体验的技术细节上，在实现功能之前建好数据模型是一个良好的习惯，Panel-Magic 还有很多比较复杂的功能点，感兴趣的可以去 Star 一下:wink:"}
{"title": "如何处理小程序独立分包的数据共享问题 ", "author": "Rolan", "time": "2020-1-10 00:55", "content": "2.3.0版本开始支持。对于短期的活动落地页，我们会选择使用独立分包，这可以大大提升活动落地页的加载速度。但与此同时，由于独立分包中不能依赖主包和其他分包中的内容，独立分包的使用也带来了一些数据共享问题。对于页面间的公用数据，我们原本的处理方式是上。但引入了独立分包后，判断的逻辑就变得复杂了。例如，我们想设计一个计数器counter，能够在小程序的各个地方调用。我们将结果记录在app.globalData.count，这时候需要分三种场景考虑：另外，对于3的情况，由于App对象可能未初始化，还要。通过wx.onError、wx.onPageNotFound等方法可以监控小程序的运行情况，我们把这些能力封装在npm包中。当独立分包和主包都引入了这个npm包，而npm包中调用wx.onXXXX方法进行了绑定，我们可以想到，当用户在独立分包和主包页面之间跳转时，事件的处理函数会被绑定不止一次（主包一次，每个独立分包一次）。对于需要在主包、独立分包公用数据的情况，我们考虑，这类似于一个，我们可以在任意场景操作SessionStorage里的公用数据，而数据会在小程序的运行过程中一直保留。对于事件重复绑定的问题，我们使用sessionStorage中的一个key来加锁。实现一个方法，保证同一个key的逻辑只执行一次，通过如下的方式来调用基于sessionStorage我们又可以实现once方法：以上，通过实现sessionStorage和once方法，我们解决了独立分包与主包之间数据共享以及事件绑重复定的问题。欢迎交流"}
{"title": "产品经理项目实录：怎样从0到1做一款微信小程序？ ", "author": "Rolan", "time": "2020-1-13 00:05", "content": "市面上有很多关于微信的文章，但大多都是一些宏观的分析或者框架式的方法论，却没有讲到底怎么去落地、以及实际项目过程中会遇到哪些问题。所以在本文中，我将以自己亲手做过的一款小程序为载体，以整个项目流程为主线，系统地解构怎样从0到1做一款微信小程序。过去几个月，我们团队一直在做一款关于互联网保险业务的小程序，这不仅是自己第一次从0到1负责一款新产品，也是第一次做微信小程序，在整个项目过程中积累了诸多经验和体悟，因此需要经过一次系统的复盘，才能真正内化到自己的产品思维体系中。我将分三部分讲述从0到1做一款小程序的整个流程：定位、规划、落地。定位，想做一款微信小程序，一定要先了解微信生态，明白服务号、订阅号和小程序之间的关系，并且基于自己公司的实际业务情况，将小程序嵌入到业务流程中去，所以我将分为微信生态和业务架构两部分进行分析。规划，把产品做复杂了容易，但做简单了难。尤其是新产品第一个版本的设计，非常考验一个产品经理的功力。哪些该第一版做，哪些该后续迭代，这都要基于产品经理对整体业务的理解进行系统规划。落地，从一个概念和框架落地为实际的产品是最难的，真正做小程序时会遇到很多的坑，不只是小程序自己的各种坑，也有与自己业务打通时的诸多问题，因此必须要对小程序的特点有所了解，我将把做小程序过程中需要注意的问题一一道来。为什么要用微信小程序这种载体？做小程序前要先回答这个问题，否则选择了不适合自己业务的载体，只能是浪费资源。而要回答这个问题，得先了解微信的生态，并结合自己的实际业务流程去权衡。其中，公众号又分为订阅号和服务号，订阅号提供的是内容，以内容沉淀用户，个人和企业均可开通；服务号则专门提供给企业，给用户提供各种商家服务。服务号和订阅号大概有三点不同：（1）服务号在消息列表这个一级页面直接单独展示，订阅号则折叠在“订阅号消息”的二级页面中。这就导致了服务号的曝光能力优于订阅号。（2）服务号每个月能推送4条消息，订阅号每天都可以推送1条消息。因此订阅号更适合做内容来吸引用户并运营用户，而服务号更聚焦于提供服务功能，并且尽量少地打扰用户。（3）经过认证的服务号支持微信支付功能和高级开发，而订阅号不支持。这进一步强化了服务号的B端属性和服务能力。从这三点区别可以看到，其实服务号和订阅号之间的差别其实非常模糊。订阅号使用H5或者小程序同样可以提供商家服务，这样就兼具内容沉淀和企业服务能力了，但服务号依旧有不能做内容的短板，唯一的优势只剩可以更容易获得曝光。也就是说，在前期，订阅号可以起到吸引流量的作用，可以当做获客渠道，用内容教育和转化用户，当用户变成客户后，就可以引向服务号，专门提供售后的各种长期服务。那又为什么会出现小程序呢？没有小程序之前，公众号的各种功能是由H5网页提供的，在服务工具或者说服务媒介这一环节不由微信掌控，而且H5的体验也较差。因此微信推出了小程序，自己制定了一套“H5”规范，这不但可以在技术层面与微信打通，可以提供更多服务接口，也能够把控工具载体的质量，为用户提供更好的服务体验。更关键的是，这也打通了整个服务链条，公众号和小程序形成了业务闭环，企业在为用户提供某项服务时，全程都停留在微信的平台上，不用离开微信这个大生态系统。打个比方，这就像微信是一个大商场，各个公众号是一个个店铺，在以前，当你进入某个商铺时，因为这是一个个H5，所以微信无法了解每个商铺的装修质量和服务能力，也不知道你在里面都做了什么，像一个个黑盒子。但现在有了小程序，也就是说微信这个大商场为每个商铺统一装修，并且把控了他们的服务质量，也都安上了安全监控，不但提高了你的服务体验，还能获取你的全程数据。其中，能收集并打通全程数据非常有意义，因为数据分析是一个系统化工程，碎片化的数据是没有价值的。比如用户的购物行为，没有小程序时，微信只能知道你点击商家入口了多少次，进入商家自己提供的H5后，微信就不知道用户在H5中都有哪些行为了，比如浏览了哪些商品、把哪些商品放进了购物车。在最后，用户付款时使用了微信支付，微信才知道这个用户转化成功了，但是中间购买流程上的每一步转化率怎么样，微信一无所知。也就是说，微信只能获取入口的流量数据和最后的支付数据，其他的数据则在商家自己手中，微信没有收集到全流程的数据，自然也无法对用户有深入的了解。小程序不但对微信的意义重大，而且对开发者来说也非常友好。由于手机操作系统是割裂的，分为iOS和Android两大阵营，所以要想开发一款APP，需要两套人马，开发两个APP，分别适配两套手机操作系统。而且Android的适配问题非常令人头疼，因为Android是开源的，很多手机厂商的系统也有很大差异，所以光处理适配问题又要花费大量的开发资源。现在微信已经成为一款10亿量级的国民级应用，渗透率极高，基本是互联网行业的基础设施，像生活中的水电煤一样。基于这个条件，在微信上搭载了各种服务后，其实微信本身就可以承担手机操作系统的角色。手机上的一个个APP也就是一个个企业提供的服务，现在微信将自己生态系统中承载的服务统一化和标准化，最后呈现的载体便是小程序。背靠微信这个巨大的流量池，开发成本也不高，小程序这个子生态系统便开始迅速成长起来，如今已经成为首选的载体。但是小程序也存在短板，因为小程序的定位是轻量、用完即走，更像是一个个小工具，具有很强的工具属性，虽然用户的体验很好，但是没有办法沉淀下来，最终还是要引向企业自己的APP或者是公众号。这也就是现在经常说的私域流量。只有变成了自己的私域流量，企业才能更直接地触达到用户，对这些用户进行运营和营销，最终实现转化。至此，订阅号、服务号和小程序之间的关系和定位就非常清晰了：小程序一定是服务公司业务的，属于业务流程中的一环。我最近在做互联网保险业务，因此所做的小程序也和保险相关：保单管理。先谈谈保险业务，可能近半的互联网人不了解保险也不关心保险，因为互联网行业兴起也没多少年，互联网从业者好多是二十多岁的年轻人群体。对于二十出头的年轻人，不关心保险很自然：一是觉得自己年轻力壮，人也常常有侥幸心理，不觉得自己会得什么病或者发生什么意外；二是因为没有家庭，所以也没有那么强的责任感，一人吃饱全家不饿。但是一旦有了家庭，尤其是有了孩子，自己也步入中年时，就会有很强的风险意识，开始考虑买保险了。毕竟就算不考虑自己，也要考虑自己的老婆孩子，比如得一场大病，不但很可能会掏空家底，而且也没有了收入来源，家里没有了经济支柱，上有老下有小的该咋办？所以保险业务的目标客户群体一般是中年人，而且一旦买保险，一定是家庭为单位进行保障规划的，给自己的父母、伴侣、孩子都购置保险。购买保险后，保险公司就会给你一张保单，也就是保险合同。一个人一般会配置重疾险、医疗险、意外险、寿险，有的人还会为自己养老考虑，购买年金险，也叫商业养老保险，这些保险具体都有什么作用就不展开了。也就是说，按照一个人平均有4张保单，那一个家庭，包括双方父母、先生太太、孩子，最少7个人计算，一家人就要有28张保单了。这些还很可能不是一个保险公司买的，所以对保单的管理就是一个很大的问题了，也是一个痛点。了解了保单管理的背景，那它在整个业务流程中处于什么节点呢？对于一个卖保险的公司，底层商业逻辑和其他行业是一致的，核心是两点：获客和转化。无论是电商平台，还是线下的商铺，都要解决流量从哪里来、又怎么转化客户以获取商业价值的问题。关于获客，虽然现在已经有诸多平台和各种类型的获客方式，比如近几年比较火的今日头条的信息流广告、抖音的短视频广告，或者是传统的SEO/SEM，到最后才发现最有效的还是微信公众号平台。在微信公众号投放广告的转化效果要明显优于其他平台。每个公众号定位不同，因此关注的用户也明显有分类，比如母婴号的关注用户大部分都是宝妈或者怀孕的准宝妈、军事类的公众号的关注用户比例最高的是中年男性。因此只要找准自己业务的目标人群，再去目标人群聚集的地方投放广告，自然会有很好的转化率。比如卖体育用品的公司，可以将广告投放健身类的公众号，卖化妆的可以投放美妆类或情感类的公众号等等。更关键的是，公众号文章不同于普通的硬广，可能不读到最后根本就不知道这是一篇广告，，不知不觉读完之后，会被文章丰富的图文和自洽的逻辑所教育，即使不能立即转化，也会对投放的广告产生品牌认知。这也是为什么，经常会有一家公司会和某一个公众号长期签约，定期多次投放相同的广告。用户价值不会一次释放完，可能第一次没有转化成功的用户，经过多次教育后就能够转化，直至一个公众号的用户群体的价值被充分压榨，转化率下降，此时公司可以转战下一个公众号了，如此循环往复。我们所做保险业务也正是采用了这样的获客方式，有了客户之后，转化环节就要靠保险销售了，把不同质量的用户分给不同转化能力的销售。用户质量也就是购买能力，可根据年收入划分为不同层次。年收入10万以下的客户，不但转化困难，而且成交后能获取的收益也很低，保险销售都不太愿意接这样的客户；年收入10万到20万的客户群体则是中坚力量，这也是保险销售群体比较喜欢的客户群体；年收入再高的话，超过50万以上，则属于高净值人群，很多对保险或者一些资产配置产品有比较深入的了解，普通的保险销售驾驭不了，适合分配给资深的销售。转化环节，其实是一整条服务流程，对于保险业务，可以细分为投前、投中、投后。（即投保前、投保中和投保后）基于整个业务架构，便可构建出相应的产品架构，即不同的产品所对应的业务环节和承载的功能。（1）保险业务后台：主要分为产品、客户和交易三大模块。（2）家庭财务智能规划系统：将转化流程标准化，根据客户的财务状况，自动计算风险缺口，并给出保险配置方案。不但可以体现出公司的专业性，还可以为保险销售节省大量的精力，让其更聚焦于为客户讲解保险知识和财务知识。（3）保单管理小程序：则承担售后服务，客户不但可以查看自己家庭购置的保单，也可以使用申请退保或理赔、续期续保提醒、保单检视等功能。了解了保险业务的业务架构和产品架构后，也就知道保险管理小程序在业务流程中所处的位置和发挥的作用了。但这也只是保单管理小程序的完整态，真正实现时，需要分步迭代。为什么说一款新产品的第一版一定要足够简单？一方面讲，第一版足够简单是一种实验思维，一旦发现存在问题，可以快速调整。甚至发现产品不受用户认可、产品方向存在根本性问题时，即使迅速抛弃现有的产品，浪费的资源也不算非常大，沉没成本在可接受范围内。互联网行业常常讲究先发优势，目前互联网保险行业的入局者越来越多，竞争也是日益激烈，所以尽快地抢先市场并占领用户认知就非常重要了。当然，产品的第一版足够简单是不够的，也要足够有用。怎么才能有用呢？经常会出现的情况是，做了一款产品，然后没有在用户核心路径上，用户可用可不用，用了固然有帮助，不用也没有什么影响，那这款产品也就发挥不了什么价值了。可以拿腾讯相册小程序举例，在初期，腾讯相册只是打通了小程序内的QQ账号体系，用户主要是查看自己在QQ的相册。而在18年5月，做了从QQ分享到微信的照片由小程序来承载这个功能后，数据量才开始爆发性增长。也就是说，从QQ分享照片到微信这个核心使用场景中，用户原来的路径是直接分享照片即可，不会是进入小程序再去分享，这个路径反而变长。但是用小程序承载后，也就是把小程序这个载体嵌入到用户分享的必经路径中了，使用量比以前自然会有大幅上涨。其负责人曾提到过，腾讯相册小程序的用户增量主要来自于QQ空间用户的分享，在小程序的新用户来源中，80%是分享进入的，也就是说每5个使用用户有4个是通过分享路径进来的。由此可见，一款新产品想要“有用”，必须要嵌入到用户的核心使用路径中。对于保单管理来说，客户在我们公司买完保险后，一定是想要直接能够看到保单的，而不是让保险销售手动发给客户一个文件或者让客户自己登录网站去查看自己的保单。所以这也正是保单管理小程序在业务流程中出现的第一个节点：客户买完保险后，可以直接在微信小程序中查看自己购买的保单，并可以获得一系列的售后服务。查看保单功能是保单管理小程序最基础也是最核心的一个功能，但是客户的保单其实分为两部分：在我们自己公司购买的保险和在其他公司购买的保险。在我们公司购买的保险，我们有相关的保险数据，所以可以直接在小程序中展示，那客户在其他公司买的保险，我们也没有相关数据，那该怎么办？尤其是自然流量的用户，不是我们平台的客户，他们又怎样使用保单管理小程序呢？这就是我们产品的另一个核心功能：上传保单。有了上传功能后，不但小程序可以独立使用了，同时，自己平台的保单数据和客户自己上传的保单数据合在一起，构成了客户的完整保单信息。当然，这个功能也应该在客户的核心路径上。客户在做保障规划时，需要纳入客户的已购保险的，不但可以将家庭财务智能规划系统计算出的风险缺口减去客户已有的保额，也可以将客户的已购保险和我们推荐的保险进行对比，最终实现让客户买到性价比最高保险的目的。也就是说，保单管理小程序在业务流程中的位置前置了，不但可以在购买保险后（投后）查看保单，也可以在投前的保障规划阶段起到录入已购保单的作用。至此，可以看到，保单管理小程序需要两个核心功能：查看并分享在我们公司购买的保单和上传在其他地方已经购买的保单。其实，这个也可以类比腾讯相册小程序。对于腾讯来说，一个人的照片分为两部分：一部分是在QQ空间和微信朋友圈的照片，也就是用户在腾讯自己公司的数据；另一部分则是用户在其他平台的照片，可能大部分都是在用户自己的手机相册中。那么腾讯相册小程序的核心功能也需要两个：用户可以查看并分享在QQ空间和微信的照片、用户可以上传手机相册中的照片。这和保单管理小程序的功能逻辑基本相同。明确了产品的核心功能后，再回到最初的问题：第一版要上哪些功能呢？哪些需要后续迭代呢？我们选择了第一版先实现用户可以查看和分享在我们公司购买的保单，也就是将保险业务后台的保单数据同步至小程序。已成交客户作为我们新产品的种子用户，可以先将小程序用起来，检验一下产品的使用效果，并优化使用过程中存在的一些问题。上传保单功能则放在第二个大版本进行迭代，有了上传功能，就不仅是一个内部应用了，可以单独使用，成为一个独立的小程序应用。这样也就有机会去获取自然流量，成为获客的另一个渠道。不过，小程序的核心定位还是形成公司的业务闭环，服务好自有客户，而所谓获客只是锦上添花，其实还是很困难的，只是提供了获客的可能。明确了业务架构和产品架构后，也确定了产品的迭代路径，接下来就要考虑产品的具体信息架构了。信息架构，也就是界面层，即展现在用户面前的视觉效果，比如不同功能的组织，页面布局等等。经常说小程序的特点是用完即走，那怎么才能达到这样的效果呢？这样用户一旦进入了小程序，就知道自己要怎么做、下一步点哪里。因为小程序有很强的工具属性，用户在进入小程序前带有明确的目的和预期，那么，好的小程序一定要让用户进入小程序时，就能使他产生一种：“嗯，这就是我想要的。”的感觉，并且顺畅和快速地让用户解决要完成的事。摩拜单车的小程序就是很好的例子：扫一扫、点击解锁、骑车即走，用户只需要三步动作即可完成任务，小程序在整个流程中的存在是完美连接线上和线下的，顺畅无阻塞，甚至是无感知的。不好的做法是，堆砌很多偏离业务主线的功能，找半天才找到能解决自己问题的功能入口，也就是把小程序做成了一个很重的APP。如果业务比较复杂，可以拆分为一个个独立业务或者功能点，做成小程序矩阵，典型如几个互联网巨头，美团、京东、百度等。这里有两个关键词：简单和统一。对于简单而言，最重要的就是不要用太多复杂的交互，更不要用太多页面跳转这么重的交互方式。不用复杂交互可以理解，因为用户打开小程序是为了快速解决问题，如果各种操作使用复杂交互效果，反而会造成使用不便。这个和PPT类似，在做汇报时，如果加入各种动效，不仅会造成喧宾夺主，听众的注意力被动效吸引，而且动效过程也会浪费很多时间。简单直接，往往最有效。那又为什么说页面跳转这种交互比较重，不推荐在小程序中使用呢？原因有两个：尤其是生活中经常会有弱网或者无网的场景出现，比如地铁、电梯、地下停车场等，因此跳转新页面会出现长时间加载情况，所以操作能在现有页面完成就尽量不要跳转。本身小程序就属于微信的子页面，至少是二级页面，如果在小程序内的页面也有很多层级或者是要经常跳转，就非常容易让用户产生疑惑或者焦虑感。同样，这也违背了第一原则。反面案例就是京东APP，拿签到模块举例，其页面层级有非常多层。关于交互的统一，本身就是一款合格的产品应该具备的。虽然一款产品可能有很多模块、很多业务，可能是由多个产品经理分工负责，但是一定要注意交互一致性、布局一致性、设计一致性。在同一款产品中，如果使用不同的功能或者模块时，发现视觉效果明显不同，那就很可能是不同产品经理做的，也说明没有一个产品负责人去整体把控这款产品。关于小程序，微信本身提供了一套标准的小程序设计规范，比如启动页加载样式、页面下拉刷新样式等等，不但可以减少很多开发量，也提供了一套通用标准，但是依旧要注意交互的一致性问题。建议先通读一下微信小程序关于设计部分的官方文档：在实际的项目中，最好由产品经理和交互设计师或者UI设计师一起基于微信小程序的设计指南，制定好一套适用于自己产品的设计规范。拿微信APP自己举例，对比其设置页的编辑态，会发现复杂的编辑操作或者重要的编辑操作，都会有“完成”按钮进行二次确认，而一般的编辑操作可直接操作。虽然这只是一个简单交互，但是说明其对设计的规范性。小程序中几个典型的交互方式总结一下：第三原则：请严格遵守第一原则和第二原则。很多时候，把功能设计得非常好用，但是往往难以落地或者是实际使用时出现了各种问题，一个很重要的原因就是数据支持没跟上。拿我之前想做的一个关于电商比价产品举例：因为现在电商平台比较多，商家也比较多，我想买一款电视，相同品牌或者相同型号的，在哪里买便宜呢？所以我就会去不同的电商平台看看，比如天猫、京东、苏宁、唯品会、甚至拼多多，在这个过程中，我需要不断切换不同的应用去对比，花费大量的时间。这个场景在生活中经常会出现，我观察到很多人也都有过相似的经历。要是从场景和需求来看，似乎电商比价这个功能非常有用，很多人肯定也非常想用，要是真的做出来了，万一大受欢迎，说不定我还可以去创个业、拿个融资，从此走向人生巅峰。但是，等一下，既然这个功能既然这么有用，为什么没人做呢？我从美好的幻想中被拉了出来，细想后发现，这里存在一个关键的问题几乎难以解决：数据从哪里来？每个电商平台都有自己的价格机制和调控平台，那商品数据和价格数据是否会开放出去呢？显然是不可能的，这些数据是电商自己的数字资产，也是自己的优势，所以一个个电商平台之间树立起了数据壁垒。从这个例子可以看到，不同公司之间的数据打通是极其困难的，不只是技术问题，更多是意愿问题。除了不同公司间的数据壁垒问题，相同公司的不同部门的数据打通同样存在种种困难。拿腾讯相册小程序举例，其功能其实也非常简单，但是难点一定是在数据上：QQ空间相册的数据、微信数据和从本地上传的数据的打通问题。因此，技术不是问题，重点在于不同部门能否通力合作去解决问题。对于腾讯这种巨头公司，经常会出现的大公司病就是“各立山头”，而QQ和微信就隶属于不同的事业群，这大大增加了数据整合、信息流通和资源共享的难度。所以不要把一个公司当做一个整体，也不要觉得一个公司是铁板一块，大家都会优先考虑公司的整体利益，毕竟一个公司是由不同的人组成的，位置不同，利益自然也不同。说完公司管理层面的问题，回到数据打通本身，真正在落地时，很难处理的是数据格式问题。虽然对于保险业务，数据格式相对来说已经比较规范了，但是依旧存在一些细微的差别。就拿我们公司叫的“保障期限”来说，也就是买一个保险能保障你多长时间，行业中不同公司的叫法有：保障期限、保险期限、保险期间、保障年限等，那么来自不同公司的保险产品数据在打通时就会存在问题。尤其是现在我们做的这个微信小程序，是一款新产品，需要使用保险业务后台的现有数据，那么在新产品中的数据字段名称和格式，一定要与原系统保持一致。在实际的工作中，数据格式这一块儿就耗费了我们非常多的精力，因为原有业务后台也存在诸多问题，很多地方的数据格式也没有统一，或者现有的数据格式不规范，因此需要先梳理现有系统的数据格式，并纠正其中的一些数据问题。数据格式问题解决之后，然后还要依照不同的维度解决接下来的一系列数据问题：在以前，进入一个APP时，需要输入账号和密码进行登录，即使是现在，主流的也是输入手机号，然后通过短信验证码登录，没有注册时还经常要先去注册，整个路径非常长。但是在微信生态中就不一样了，进入小程序时是静默登录的，在小程序后台直接完成了登录操作，企业可以获取到用户在此应用中的唯一标识OpenID，用户不需要进行任何操作。这个也好理解，用户进入微信APP时，已经进行过一次登录，那再使用微信内的应用时自然不需要登录。那我们为什么还会在各种小程序中看到“登录”按钮呢？其实，这里的“登录”本质是授权，是为了获取你的各种信息，因此是两回事。可能许多应用为了延续用户在APP生态中的使用习惯，所以依旧使用“登录”这种叫法。微信本身就有你的手机号、身份证、年龄、性别、地域等关键信息，但是不会直接开放给其他企业，需要用户手动授权。其中，手机号信息又从用户信息中抽离出来，需要用户单独授权，毕竟手机号是一个非常关键的用户信息，可谓是现在的互联网通行证。所以，微信的信息授权分为两种：一种是手机号授权、另一种是用户其他信息授权。这两种授权非常简单，只需要一步点击操作，即可触发微信登录底部弹窗，直接授权手机号或者用户基本信息，比传统的登录操作要便捷很多，这也正是微信生态的优势所在。但是出于对用户信息保护的考虑，也为了避免打扰用户，微信对用户信息授权的触发方式做了各种限制。这不得不提微信的审核机制。微信的小程序生态和苹果的应用生态非常类似，新开发的应用都需要审核通过，才能上架开放出去。开发iOS版本的应用时，很多开发者经常会遇到审核不通过的情况，因为苹果制定了一套审核标准，必须符合苹果的设计规范和基本要求才能通过，否则要被打回修改。微信沿用了苹果的审核机制，同样制定了一系列的标准。我们在这个项目中就遇到审核不通过的情况，被打回的原因就是：授权方式不规范。“你好，小程序帐号登录功能暂未符合规范要求，请在用户了解体验小程序功能后，再要求用户进行帐号登录。请整改后再重新提交审核，具体登录规范及整改可参考：https://developers.weixin.qq.com/community/operate/doc/000640bb8441b82900e89f48351401请根据上述原因对小程序进行修改，并重新提交代码审核。若对上述原因无法理解，可前往反馈页面进行反馈。我们原来的设计方案是：用户进入小程序后，会显示启动页，手机号和用户基本信息授权成功后才能进入小程序主页面。但这是微信不允许的，简单说，就是不能一进入小程序就直接弹窗提示用户登录，必须要让用户看到小程序的主体内容后，并手动点击按钮去触发登录弹窗。就连我们这种用启动页过渡的方式也是不允许的，必须要进入小程序并看到一级页面才行。最后我们不得不临时改动产品方案，在首页和“我的”页中分别增加了授权手机号、授权用户信息两个触发按钮。用户授权的底层是和用户标识有关。为什么我们需要用户标识呢？有两方面作用：一是微信用户数据与外部数据的打通，也就是与自己的已有业务数据打通，比如某个用户已经在我们的后台有了购买数据，那么我们只要确定了他的身份，然后和我们后台的客户标识进行对比，就可以知道他到底是不是我们的已有客户。目前用户唯一性的通用标识是手机号，因为手机号是实名的，与身份证绑定在一起。确定了一个用户是我们后台的已有客户时，就可以直接把他的购买数据推到小程序端，这个用户也就可以看到自己的保单数据了。二是微信内部不同应用数据之间的打通，确定了用户的唯一性后，其在不同微信应用的行为数据或业务数据就可以串在一起了，比如在订阅号的阅读数据、在小程序中的行为数据等。每一个人都是一个数据源，无时无刻不在创造着各种数据，只不过这些数据要么没有被收集到、要么散落在不同的应用中，所以我们若能收集到这些在不同场景中的碎片化数据，并想办法归类到创造这些数据的同一个人身上，我们就能更加全面的和深刻地了解这个人。这也就是所谓用户画像的由来，只不过现在大多数的用户画像还非常单薄，可能只有性别、年龄、地域、手机设备型号等属性数据，而没有更加深入的、更加细节的信息。比如从一个人的外卖数据中可以了解到他的饮食习惯，也可以知道他的长住地，公司或者家庭地址等；从一个人的购物数据中可以获取到他的最近生活方式变化，像开始买纸尿布，推测其有了孩子，后来又买了童装，则说明他的孩子长大了；从一个人的聊天记录数据和通信录数据中可以抽离出更多的有效信息，这个人的说话方式、关系网、最近的心理状态等等。唯一的问题就是这些不同场景的数据在不同的平台中，而且是非格式化的数据，包括文字、视音频等主动数据和点击查看等被动数据。那么我们就需要每个用户都有唯一的标识，并将其在不同的应用中的不同唯一标识串起来。在一个应用内，比如小程序、订阅号或服务号，每个用户都会打上唯一标识，这个就是OpenID，为什么叫Open呢？因为这个ID会提供给应用所属的企业，但是为了保护用户隐私，也是为了保护自己的数据资产，微信肯定不会直接把手机号、微信号等重要信息给其他企业，所以这个公开的ID是经过特殊规则转换过的一个特殊字符串，不包含任何明文信息。但此时也会出现问题，要是一个企业有多个小程序，还有订阅号或服务号，那一个用户在同时使用这些应用时，在每个应用内都有一个唯一标识，也就是会有多个OpenID，那到底有多少真实用户呢？而且单个用户在不同应用中的行为数据怎么串起来呢？总不能一个用户在订阅号中标识为用户A，跳转到小程序后，就标识成用户B，然后数据也就被割裂开吧？于是，便有了UnionID，就像字面上的意思，联合的标识。有了UnionID，同一用户在不同应用中的不同OpenID就可以映射到唯一的UnionID上了。简单总结：OpenID是不需要授权的，在公众号中，关注公众号时企业可以获取用户的OpenID，在小程序中，进入小程序时即可直接获取。但是UnionID则不同，在公众号中，不仅需要用户关注我们的公众号，还需要开发者去微信开放平台绑定公众号后，才可以获取UnionID；小程序获取UnionID的规则更复杂一些，用户进入小程序时，如果用户已经关注了与小程序同一主体的公众号，而且公众号已经获取了用户的UnionID，而不需再次授权，否则的话，需要在小程序中单独授权才能获取UnionID。在项目完成到最后阶段时，数据指标一定不能忘，数据指标是量化评估你所做需求的实际效果的关键。关于数据埋点，分两种情况：事无巨细地追踪所有用户行为，需要全面铺上数据埋点，工作量巨大，对于正在快速迭代的初创企业确实不太现实，可能几个月后才能看到数据，所以建议采取分级分步的方法，优先定义出最重要的几个事件追踪，然后再做其次重要的事件。不过好在微信小程序本身就提供了基本的数据统计，而且还有直接配置的埋点方式，无需代码，这样就简单很多了。在微信小程序后台，整体可分为常规分析和自定义分析。常规分析就是不需要自己数据埋点，微信直接就能收集到的数据，分为三类：自定义分析也就是数据埋点，分了两种方式：直接配置和API上报。1）直接配置只需要填写事件名称、触发动作和页面元素的ID即可，不需要添加代码，也不需要上线，这种埋点方式适合统计功能的使用情况，比如多少人点击了签到按钮、多少人进入设置页面等。2）API上报适用于收集事件下的具体属性数据，比如点击商品这个事件，如果我们想要知道用户具体点击了什么商品、商品的价格是多少等信息，就需要这种添加代码的数据埋点方式了。从另一个维度看，数据又可以分为两大类：用户数据包括用户画像和行为数据，业务数据则是和业务直接相关的数据，比如购买金额、购买频率等。对不同类型数据的分析要在不同平台处理，微信小程序提供的数据分析更多是集中在用户数据部分，业务数据则主要在公司自己的业务后台。“如果你从头开始建立用户行为追踪计划，建议先找到3个最重要的一级事件，这3个一级事件，应该代表了用户从初次接触产品到最终成功使用产品的最重要的里程碑。”这是我之前在书中看到的埋点理论，把这个理论用到我们的产品中，最关键的3个一级事件是：进入小程序（PV/UV）、关键功能1的按钮点击（PV/UV）、关键功能2的按钮点击（PV/UV）。当我按照之前在书中看到的这套理论梳理了三个关键指标后，才发现实际情况没有这么简单。先是leader直接就发现了问题：这不是关键指标，应该和业务结合，目前最重要的是要让保险销售知道自己名下哪个客户有没有使用小程序，然后推动客户去使用，如果用简单的PV、UV、按钮点击等等，对业务没有什么帮助，适合后期再去完善。之后又深入思考了现状：我们现在有2个微信公众号和即将上线的2个小程序，已经构建起了一个微信生态服务矩阵，因此要考虑到4个应用之间的互联互通，而不只是我现在负责的这个小程序需要收集使用情况的数据，其他两个公众号和另一个小程序同样需要。那我们怎么把这几个微信生态应用的数据使用情况集合到一起呢？我们了解到另一个产品经理正在保险业务系统中做用户行为轨迹模块，即收集一个用户从接触到我们的品牌、到使用我们的服务、再到满足需求，整个业务流程的数据。这两个小程序的使用数据也正是整个业务流程中的一部分，他现在已经收集了公众号的使用情况，因此可以把两个小程序的使用情况也放到这个模块中。也就是说，我们把我们想要的数据需求提交给另一个负责用户行为轨迹的产品经理，把数据融合在他所做的模块中，然后我们这边再做一个用户是否使用小程序的提醒功能即可，这就实现了一个新小程序的初步数据统计需求，之后再按正常流程提数据埋点需求，把核心页面和关键流程都铺上点。我们产品内部策划好这个需求后，再与程序员沟通时，又遇到了一个问题。因为没有事前规划好，已经临近小程序上线，即使需求较小，现在再改代码会打乱发版节奏，所以开发建议在上线后一周内紧接着迭代一个小版本，把一些上线后暴露出来的问题和这个埋点需求整合在一版中。经过评估，这也在可接受的范围内，所以就按照这个节奏执行了。这才是实际业务场景中遇到的真实情况，而不是书上讲的那么清晰和简单。所以，并不是知道了一个方法论或者一个道理就可以直接套用，而是要结合实际的业务再次深入思考，并根据实际情况及时调整才能真正解决问题。从定位、到规划、再到落地，一款微信小程序历经打磨后终于上线了。根据线上的数据和用户反馈，然后开始进行下一版的迭代，不但要解决线上的一些问题，还有可能要修正原来的规划方向，毕竟真实的效果和自己最初的设想常常会有非常大的出入。目前这个项目已经迭代了两个大版本。如果问我在这个项目中收获最大的是什么？还是最开始时说的：首先是从0到1做了一款新产品，这让我对整个产品的规划能力有了很大提升，也对公司内部不同系统之间的协同与配合有了更深的理解；其次才是做了一款微信小程序，对微信生态有了更多的思考，对小程序的特点有了更多了解，只有先掌握好小程序这个工具，才能更好地服务实际业务。做产品，和拍电影或写东西一样，形式与内容，两者不可偏废。本文由 @岳小鱼 原创发布于人人都是产品经理，未经许可，禁止转载。题图来自 Unsplash，基于CC0协议"}
{"title": "小程序登录的最优流程 ", "author": "Rolan", "time": "2020-1-13 00:16", "content": "18年中旬做过一个，当时是通过转跳到一个登录页，然后点击调用，然后发现这个api被禁用了(虽然依然可以用)，然后用因为当时刚好需要用户信息，然后这个api有一个属性可以获取信息。这样的流程本就可以了，但是意外出现了。当第二次(2020年)需要开发一个新的小程序，于是也用了老代码，因为微信限制无法转跳到登录页，所以想是否应该在首页设置一个弹窗，点击的时候授权。但是因为考虑到可能会被微信拒绝，故在小程序开发者论坛开了一篇文章随后发现，登录其实并不需要授权弹窗or页面。（如果服务器不需要保存用户信息)下面这个图是小程序官方图app.js（小程序的入口文件）的完整代码这是我通过拿到openid的截图（因为这个是测试号，所以没有unionid）【unionid】是拿来和其他平台打通账号的关键，如果只有一个小程序，都可以不需要这个。--完--"}
{"title": "微信小程序 动态加载swiper时不显示的问题（爬坑） ", "author": "Rolan", "time": "2020-1-13 00:24", "content": "报错信息解决方法：因为会保留上一次滑动swiper时候的current，所以会出现上次滑动到的current在这次的数据中不存在问题，所以，每次动态加载swiper-item前，需要设置swiper的current属性为0swiper 的current每次设置了0，但是还是不显示 swiper，检查元素是存在的，并且current = -1解决方法，动态设置swiper-item的数据时，还需设置current = 0，并且current和swiperList不能在一个this.setData中设置，要先setData swiperList 然后在setData current我是这样写的：之后没有问题成功解决，希望对你有所帮助。"}
{"title": "京东购物小程序cookie方案实践 ", "author": "Rolan", "time": "2020-1-13 00:32", "content": "早期为了解决“会话保持”的需求，社区中出现了「cookie方案」并最终成为W3C标准：当某个网站登录成功后，客户端（浏览器）收到一个cookie标识（文本）并保存下来，在后续请求中会自动带上这个字段，由此Web后台可以判断是否同一个用户，从而使“会话”得以延续。微信没有像浏览器一样内置实现了cookie方案，需要开发者自行模拟，而原先京东购物小程序及京喜小程序（现微信一级购物入口）是从微信及手Q购物H5中迁移迭代出来的，也就是说我们不仅要在小程序中模拟一套cookie方案，并且要保持和原业务对cookie处理逻辑的一致，为此我们将实现方向确定为“基于小程序开放能力，和浏览器保持一致”。微信小程序开放了和这两种能力，通过这两套API，我们可以自行DIY一个cookie方案。PS：本文所有代码及使用示例都可以找到，阅读本文时配合实践，效果更佳。为了保持后端对cookie的处理逻辑和原来的H5一致，小程序的实现需要往浏览器看齐。所以模拟小程序的cookie前，先看看浏览器的cookie机制，主要有以下几个部分：在浏览器的中，可以看到当前站点下的Cookie明细：在小程序中模拟Cookie，主要涉及五个部分：其中我们会重点关注 「Cookie基础库」 的实现，另外也会给出「Request基础库」的封装示例。小程序提供了 「数据缓存 Storage API」（可以理解为Web规范中的），支持存储“原生类型、Date、及能够通过JSON.stringify序列化的对象”。我们可以利用这些API，在Storage中新开一个字段进行存储：其中的「存储结构」如下：上面的便是一个“最小cookie单元”，包含了3个字段（name、value、expires），是本文中定义的「标准cookie格式」，也是cookie操作的基本单元。打开【微信开发工具】的选项卡，可以查看本地存储的情况：这部分主要作为“公共基础库“的角色，为外部业务提供增删改查cookie的API。1. 获取cookie————步骤：从Storage中取出完整cookies ==> 取出指定name的cookie项 ==> 校验有效期 ==> 返回值value实现如下：2. 设置cookie————步骤：从Storage中取出完整cookies ==> 解析入参 ==> 覆盖更新 ==> 同步到本地Storage首先看下本API设计需求：调用示例如下：这里可对入参遍历，而cookie子项无论直接传值value还是传了详细object，都尽量的获取，传给格式化函数转为标准的：3. 删除cookie————步骤：从Storage中取出完整cookies ==> 删除指定的cookie项 ==> 同步到本地Storage本节主要简单实现设计图中的【Request基础库】部分如上图所示，Cookie在网络中的传输主要有四个过程：以下是对一个请求的抓包示例：在小程序中，请求发起有两种方式：和，这里以HTTP为例，先对请求api进行「封装」：如上代码所示，Cookie在前端侧请求模块中的处理主要有3点：步骤：（每次发请求前）从Storage中取出完整cookies ==> 转化为HTTP规范的请求头Cookie格式 ==> 设置到中上面代码中的直接取cookies拼接即可，返回示例：。步骤：（每次收到响应后）解析的字段 ==> 转为标准Cookie格式 ==> setCookie()这里处理内容时，有几个点需要留意： - 最基本的格式：- 可能同时包含多个cookie字段，以,分割（但需要排除时间值里的,） - 时间格式：Max-Age/Expires （不区分大小写）具体实现可在文末Demo中找到。「Cookie值编码方式」是容易产生困惑的地方，目前看到的广泛做法都是使用「URL编码」。但笔者翻阅发现，原始规范中并没有对编码进行指定，比如在第四章 Server Requirements （服务端）中是这样描述：“为了最好的兼容效果，服务端应该对cookie值进行编码，例如使用Base64。”而在第五章 User Agent Requirements （客户端，也就是浏览器），则是“建议以第四章服务端的实现为准”。总之规范并没有指定使用「URL编码」，但基于该编码方案已经深入人心，也就顺其自然成了“默认选择”。那这里也不做例外，浏览器怎么做，咋们小程序也保持一致。在浏览器中，推荐cookie值经过编码后保存下来，所以直接取到的也是后的值，所以追加在请求头字段，就不需要解码了，直接拼接即可（但基础库API的get操作最终需要进行解码）。而对于响应头的值，我们认为后端已经做了编码，所以前端不需要处理，直接存进 Storage 即可。前面实现中每次读写cookie都会调用小程序Storage API（而且是同步的），小程序框架会读写到本地Storage。 对于高频场景，可以将cookie在内存中维护一份，读写都直接走「内存层」，有更新才同步到「Storage层」。首先需要在内存中声明一个（命名自行diy），建议在cookie基础库中声明，便于统一维护。前面初始化时已经从Storage读取一次cookies，后续getCookie就直接读内存的即可。写操作直接更新内存，间接更新Storage。 如果有高频写场景，可以考虑做个任务队列进行节流。微信官方在2019年5月推出了「小程序自动化 SDK」，经过半年多的迭代，目前已基本稳定下来。在购物小程序场景试用了一下，cookie相关的用例很快就完成了，简直是开发者的福音：真香！！！实际项目中，对cookie的单元测试可以分为两类：以验证API为例：这里为了方便测试用例调用基础库API，在小程序启动前，把Cookie基础库（CookieLib）挂到了对象上，实现方式是使用node读写文件的API去【植入代码】：Cookie安全是一个比较大的话题，这里只简单列出和小程序相关的几个点。小程序中已经做了一些安全措施，比如只能走HTTPS、合法域名需要管理员到微信后台进行配置、Storage只能由写入它的小程序中访问，等等。 因此这些字段在小程序环境下的价值没有浏览器环境大，本例中没有使用（懒..），而实际业务场景可以按自身情况决定是否要使用。前端维护（大小/数量） 通常浏览器保持的Cookie数据不超过4k，部分浏览器限制同一站点最多cookie数为20个。 如果业务庞大的话，建议在Cookie基础库做一套「白名单」机制，在白名单内才可以写入，以此防止“非法写入”或“内容超大导致信息丢失”的问题。后台维护（网关白名单） 同样的，建议从网关层面，建立一个“可信cookie”白名单，自动过滤请求中的“非法cookie”字段。小程序前端更多是防“误改”————即在操作Cookie过程中，发生了意料之外的修改。通常发生在JS“引用拷贝”特性上，比如前面提到的内存维护一个，如果有一个API直接将这份内存版cookies暴露出去，对象引用容易被连带修改。所以cookie基础库需要控制暴露API的能力范围，并对取值进行“深拷贝”。Session机制将用户状态放在了服务端维护，具备更好的安全性，而且目前各种后端对于session的存储和同步都有很成熟的技术方案，有条件的业务应以Session为主做会话保持。用户访问时生成设备指纹并上报（通常是登录/结算等环节），业务后台配合风控系统，遇到异常请求时下发验证环节。代码片段：本文先解析了浏览器的 Cookie机制 运作原理，然后使用「数据缓存」和「网络」能力，以 公共基础库 的形式，在小程序中实现了一套 Cookie方案。希望对大家有所帮助。"}
{"title": "迷你PS小程序-集成的开放式画报、油墨电子签名、图片拖拽可单独食用 ... ", "author": "Rolan", "time": "2020-1-13 00:58", "content": "米娜桑，哦哈哟~个人制作，该文章主要讲解最近基于框架编写的集图文拖拽等多方位编辑、油墨电子签名、开放式海报于一体的的制作思路和实现代码。1、完整源码链接2、实现思路3、核心代码3-1、图文多方位编辑3-2、油墨电子签名3-3、开放式海报3-4、小结4.效果展示和体验完整代码：https://github.com/TensionMax/mini-ps其中演示的文字编辑、图片编辑、油墨电子签名、开放式海报可单独食用，含文档说明。该工具主要由五个不同组件模块：文字编辑、图片编辑，油墨电子签名、控制、开放式海报1、文字编辑模块设置好的文字参数对象插入到文字队列中。2、图片编辑模块设置好的图片参数对象插入到图片队列中。3、油墨电子签名模块完成绘制后转为利用转成临时图片，获取参数后插入图片队列中，也可以直接导出。4、利用控制模块调整/文字队列和图片队列的参数。5、开放式海报模块，利用控制台的参数将PS画板上的效果绘制到canvas上来实现的效果，接着再利用转成图片导出。文字/图片编辑模块主要是实现移动/缩放功能，其他附带的属于甜品，由于两个模块功能类似，该篇仅讲解图片编辑模块。在的数组标签中，每个绑定的事件中用来调用事件本身的参数，其中的或包含我们需要的位置参数，示例如下：长度为2代表双指触碰，通过判定双指触摸点的变化方向可实现双指缩放效果。因为每个标签都设置为所以只需要根据位置参数来更新即可一次移动多次操作DOM影响性能——为何不用事件委派——由于事件在小程序真机的触发频率和精确度很迷，不太好根据速度来判定绘制的线宽，我只好用其他方式去实现，虽然效果不完美。其实现思路是通过多次的循环绘制以达到油墨效果，每次循环绘制的长度和宽度都不相同。使用的大部分是canvas的基础api，注意绘制单位都为px。如果说微信小程序是银色金滩，那么截至2020年1月6日或者未来，小程序的canvas就是金滩上充斥着未知数个的玻璃块的那一片 ——说起小程序canvas，那bug不是一般的多，部分不常见bug我会在代码注释里说明。如果图片是网络路径，记得获取临时路径。JAVASCRIPT输出字段部分JAVASCRIPTrpx 或 upx与 px 的单位统一转换方法JAVASCRIPT绘制图片的函数绘制自定义文字文字绘制稍微麻烦些，主要是canvas不会自动帮我们换行排版，网上类似的实现方法太多，该篇就不讲，直接放在Demo里面。既然我们知道了这几个组件自定义调整参数的方式，那么最后只需要一个父组件作为控制台来调整他们的参数即可，可以通过、等来实现父子通信，当然如果想做更复杂的可以考虑用传参。接下来就可以根据这思路来实现繁琐的业务逻辑了。效果图如下，如果由什么疑问欢迎到下方评论区讨论。"}
{"title": "张小龙与其说是“未完成”，不如说是“没想好” ", "author": "Rolan", "time": "2020-1-14 00:04", "content": "题图｜虎嗅“公开课”这个古典互联网时代的名字，如果不是微信，可能早就寿终正寝了。同样的，“微信公开课Pro”如果没有张小龙加持，可能也无法Pro了。1月9日的2020微信公开课Pro，主题叫“未完成”。尽管张小龙“故意”缺席了这场微信每年最隆重的开发者大会，这几天还是获得了各媒体同仁从产业、行业、产品、人性等各方面、各种姿势的赞美，篇篇貌美如花。有人赞美张小龙的克制，有人盛赞微信取得的成绩，有人说他说了12分钟的视频丝毫不亚于去年4个小时的演讲，有人把他捧成了“上帝”，亦有人说张小龙进化了……我先旗帜鲜明地表明我的态度：他们的观点我都举双手认同。根据微信2019年度报告，微信月活跃用户数突破11.5亿，同比增长6%。在这个庞大的数据支撑下，在克制的张小龙故意没来的情况下，微信公开课的各个讲师轮流上阵，从到小游戏，从微信AI到微信支付，交上了一份让人亢奋的答卷——小程序。小程序的活跃用户数突破了3亿，用户人均使用小程序的个数增加了1倍，2019小程序累计创造了8000亿交易总额，同比去年的数额增长160%。小游戏。微信表示，小游戏平台累计注册量超过10亿，小游戏平台商业规模的总量相较于2018年增长35%。经过一年的时间，创意小游戏已有47款通过，其中14款产品MAU峰值超过100万，4款产品累计流水过千万，创意小游戏开发者多获得了超过6000万的现金激励，其中优秀产品《消灭病毒》开发者分成超过2亿，《动物餐厅》累计用户和流水均破亿。微信支付。主要讲了微信支付分——类似于支付宝芝麻信用分，主要功能是免押金——微信表示，2019年微信支付分服务了1亿的用户，原本的押金用户中80%的用户再也不用使用押金服务，这一年微信支付分为用户减少了押金千亿。尽管如此，我依然认为，今年的腾讯公开课Pro是最平庸的一届，或者说乏善可陈。开场前的前菜依然是小游戏。工作人员提示连接现场Wi-Fi下载最新版微信7.0.10抢先体验最新功能，但现场Wi-Fi根本连不上，由于人群密度极高，连4G下都扫不了二维码，向来以注重用户体验为荣的微信，奉献了一场让人恍惚回到2G时代的开场。张小龙在开场视频结束后，很多慕名而来的观众就带着失落走了。现场不到11点就有不少人陆续离场，11点半后会场最后面那些座位几乎都空了。显然，张小龙的缺席还是让那些来“朝圣”的人失望了，本以为花了钱买了门票可以隔着人山人海看张小龙本尊一眼，结果这个中国最牛的产品经理任性地没来。不过这倒是没影响堵着会场门口卖票的黄牛们。在会场入口处，十几个黄牛大哥不停地问路人买不买门票，价格好商量，“没有门票进不去晚上的微信之夜”，据说门票价格1699元一张。有一位黄牛以为我在拍他，跑过来要看我手机，嘱咐我千万别拍，他们这些人每年都会准时出现在微信公开课的门口，有的已经连续好几年了。相比往年微信公开课Pro推出小程序和小游戏等产品，今年没有什么新东西，几乎都是更新最新的数据来吸引开发者。但虎嗅作者南七道在《》一文里指出，微信小游戏抄袭成风——“没有版权的概念，所以现在是小游戏一大抄。国内的抄国外的，国外的也彼此抄袭。国内没火的，抄火了的。如果小团队被大团队抄了，基本上就是等死。”这是李超入行之后最大的感受。即使最火的小游戏“消灭病毒“，也是在国外热门游戏《Ball Blast》上进行了二次改编。这款游戏一年的分成高达2.6亿。成为了整个微信小游戏的头部标杆。创始人周巍曾经分析这款游戏诞生的过程，“看看市场上哪些产品表现比较好，做二次加工，产生新的玩法。像《消灭病毒》的商业化模型就是《Ball Blast》。”“基于《Ball Blast》的核心玩法，我们在操作，题材、手感和目标设计上做了大量的二次加工。”……即使抄好了，游戏上架，能不能火，谁都不知道。因为微信小游戏，是一个完全去中心化的平台，没有入口，没有推荐位，完全靠用户搜索和开发者自己推广。从好的一面来看，就是没有人工干预，很难舞弊，但从坏的一面来看，即使很好的游戏，也没法得到推荐，要看运气了。希望微信重视这个现象。下午4点多，我走进搭建的“未完城”闲逛，依然是白色的统一风格，除了微信官方的We Store展区，其他各厂商的展区门可罗雀。本来想在We Store买点儿东西，但发现无论是卫衣、T恤还是各种玩偶、配件都跟去年展出的一模一样，没有更新，手机壳是iPhone 8的，有一套公仔套装还是猪年的。张小龙说：“微信作为一个基础的信息传递的工具或者说平台，我们一个不经意的动作，可能会引起信息洪流的流向的变化。”深以为然。大家应该还记得2019年12月26日微信公众号后台出现故障，导致无法登录后台、亦无法打开公众号文章给人带来的短暂“恐惧”。感佩张小龙的谨慎，但显然他也在谨慎地妥协。在微信公开课开始前的2019年12月23日，微信按照惯例更新到7.0.9版，支持朋友圈评论区发布自定义表情包，结果很快有人发现有些不可描述的表情包陆续出现，两天后微信官方宣布此为灰度测试，随之关闭。还有人在微信公开课前发现，微信好友上限已经允许突破5000个，不过超过5000后再加别人微信好友则只允许聊天，无法查看对方朋友圈等正常功能，这显然对新“好友”不友好。“之前我们限定一个人最多5000个好友，现在有将近一百万人已经接近5000好友。虽然不是真正意义上的好友，但也促使我们要扩大好友数目了。”张小龙在视频里隐隐不安地说，“我们扩大5000好友这个限定非常容易，但是对于它带来的影响，说实话诚惶诚恐，我们会反复思考。”显而易见，张小龙还没想好要不要讨好用户。所以，与其说微信公开课今年的主题是“未完成”，不如说是“没想好”。"}
{"title": "微信小程序搜索优化指南 ", "author": "Rolan", "time": "2020-1-14 00:12", "content": "有流量抢夺的的地方就会自然有战场，搜索能力升级后，现在用户可通过关键词的搜索即可直达小程序页面内的服务，这将缩短用户使用小程序所提供的服务之间的时间，提升搜索效率的同时也帮助优质的小程序获得更多的曝光。微信在2019年重点对搜索进行了升级，开放了小程序基于页面的搜索，搜索将不再局限于搜索具体的某一个小程序名称，“小程序名称”的优势已经下落神坛。目前搜索是当下小程序唯一的自然流量来源，用户在使用搜索的情况下用户需求十分精准，所以搜索场景的流量价值非常高，带来的用户在后续的留存的表现中也会高出其他场景很多。有流量抢夺的的地方就会自然有战场，小程序搜索能力升级后，现在用户可通过关键词的搜索即可直达小程序页面内的服务，这将缩短用户使用小程序所提供的服务之间的时间，提升搜索效率的同时也帮助优质的小程序获得更多的曝光。微信公开课PRO 张小龙也说道，做小程序希望是搜索能进入到每一个小程序内部，这样海量的小程序可以支撑起各种长尾的搜索需求。下面一起来看看微信近期最新发布的小程序页面收录规则，希望能够助你瓜分部分流量。小程序页面收录通过管理后台页面收录开关，来配置其小程序页面是否允许微信索引。后续小程序相关页面内容可以通过 sitemap.json文件进行配置，该文件用来配置小程序及其页面是否允许被微信索引。如果小程序目录没有该文件，打开“页面收录”后就会默认小程序所有页面都可以被索引。微信会通过爬虫的形式，为小程序的页面内容建立索引，同时会带上1129的场景值。当用户的搜索词条触发该索引时，小程序的页面将可能展示在搜索结果中。如果直接关闭收录能力，微信将不会进一步收录你小程序内的任何内容，意味着你的小程序内容（包含已收录内容）无法在搜索和扫条码场景下展现，这将减少你的小程序曝光机会。当存在不便于被微信收录的页面时，也可利用sitemap文件进行配置，将一些用户个人信息、通信信息、商业秘密等敏感内容，设置成不允许索引状态。sitemap文件配置目前包含以下5种规则：如果小程序想突出一些主打的价值页面，可利用页面路径推送能力，让部分页面被优先且及时的收录，进而提高小程序内容的曝光机会，并且缩短用户体验路径。页面标题和缩略图对于微信理解页面和提高曝光转化有重要的作用，那么何为“清晰的标题”，个人猜测是根据页面标题进行语义识别，分词后划分各词权重配合缩略图来进行收录以及搜索结果展示。比如页面标题为“精选日签推荐”，假设分词结果为“精选”、“日签”、“推荐”，那么假设“日签”的权重为88，其余为45、33。使用页面路径推送能力，直接搜索关键词“日签”，搜索结果就有可能包含该页面。以上个人猜测是头部流量的情况，根据关键词权重进行收录及优先排序。还有一种情况是尾部流量，微信公开课PRO 张小龙也说道，做小程序希望是搜索能进入到每一个小程序内部，这样海量的小程序可以支撑起各种长尾的搜索需求。尾部流量指的是一些流量比较低的一些关键词，但尽管这些关键词搜索量很低，但它们加起来的可能占总数的一大半。比如做的是一款“壁纸类小程序”，发现“新年壁纸”以及一些“娱乐明星壁纸”占据很多搜索量。对于一些初创企业，想竞争一些头部关键词比较难。但如果利用尾部浏览比如聚焦于“NBA球星”，就有可能撕开一个口子。当然，以上例子仅供参考，微信并没有明确的公布搜索结果排序规则，只能靠猜。实际情况最好配合“微信指数”以及小程序页面访问情况来进行优化，如果发现局部页面比起其他页面访问量明显高一个档次，该页面对应的微信指数又不是很高的情况下，那么我认为可以使用该策略。如果不自定义转发图片的情况下，默认会取当前页面从顶部开始，高度为 80% 屏幕宽度的图像作为页面缩略图转发出去。个人建议小程序核心页面还是自定义为佳，因为微信默认截取的部分很可能缺失部分画面。其次用户转发时，缩略图也有刺激用户打开的欲望，通过好友转发打开是目前小程序流量top3的来源。此外最好也给 video、audio 组件补齐视频封面属性，用于给搜索等场景作为视频封面展示，建议使用无播放 icon 的视频封面图，微信之所以要求没有播放icon应该是避免icon的遮挡，导致视频封面的识别不佳。微信一直提倡的“一切以用户价值为依归”，所谓合理即在必要的时候才要求用户授权，比如浏览动态可以匿名，而发表评论需要留名，从而用户在发表评论时才请求授权。如果某类小程序一启动就必须注册成功后才能使用，从业务上考虑注册操作不能滞后，那么大概率该类型小程序与收录无缘，因为可能会发生收录错误。如果小程序某些页面是嵌入web-view，而不是小程序原生页面，无法收录里面的任何内容，微信团队称目前做法做到，长期来看也可能做不到。毕竟还是把时间和力气花在刀刃上，从布局和趋势来看，猜测小程序还有更多有价值的事情值得去做。比如“在微信搜索商品”，这些功能可以很好的满足微信用户对商品的信息获取诉求，同时也能为商家小程序带来曝光流量和建立用户品牌认知的机会。小程序页面内的跳转url是微信爬虫发现收录页面的重要来源，且搜索引擎召回的结果页面 (url) 是必须能直接打开，不依赖上下文状态的。特别建议页面所需的参数都包含在url，以保证每个独立页面能够打开，便于爬虫收录。结构清晰、简洁、参数有含义的 querystring 对抓取以及后续的分析都有很大帮助，但是将 JSON 数据作为参数的方式是比较糟糕的实现。这里是建议不要将json作为url的参数，过于冗长，但是和第一条是有点相互矛盾，即想页面跳转不依赖上下文，又想参数简洁。多的不说，抽屉多准备点零食给研发大佬吧。微信建议页面之间的跳转使用navigator组件，目前小程序提供了两种页面路由方式。微信所提倡的是使用 第一种navigator 组件。两种的区别应该就是我骑着自行车和开一辆大奔回丈母娘家，开大奔必然要走机动车道，走机动车道必然会被摄像头捕捉，而骑自行车可以走胡同小道，胡同小道难以被摄像头捕捉。第一种更方便微信爬虫捕捉。参考资料：https://developers.weixin.qq.com/community/develop/doc/000a0a1191c3a817e7a9c6f1e51409?page=1#comment-list动物园园长，微信公众号：首席吹牛官，人人都是产品经理专栏作家。互联网圈十八线作词人，国家一级退堂鼓表演艺术家。颜良而文丑，欢迎交流。本文原创发布于人人都是产品经理。未经许可，禁止转载题图来自Unsplash，基于CC0协议"}
{"title": "小程序、H5登录授权、分享、支付流程 ", "author": "Rolan", "time": "2020-1-14 00:32", "content": "对于前端来说，微信的、、是一定要掌握的，今天这篇文章，主要对这三方面的流程进行详细的介绍。主要内容如下：如果你从来没有阅读过小程序登录授权的文档，建议你看一下下面的地址：在里面，定义公用的和然后通过调用小程序的接口，获取到传给客户端的编写上述代码的和是封装的对数据的统一处理，如果有兴趣，参见地址。这里不展示代码。需要注意的是，这种实现方式，获取的行为放在后端实现了。如果放在前端实现也可以，但是会相对比较麻烦一点。此时，suerId就已经在数据库存储，并且在本地保存了，下次登录的时候，如果有userId存在就不需要再次登录了。H5的登录授权略有不同。如果用户登录授权页面，发现该用户没有登录授权，则需要跳转到授权页面。给出的流程如下：1 第一步：用户同意授权，获取code2 第二步：通过code换取网页授权access_token3 第三步：刷新access_token（如果需要）4 第四步：拉取用户信息(需scope为 snsapi_userinfo)5 附：检验授权凭证（access_token）是否有效在项目中代码如下：(这里代码没有实现刷新access_token和拉取用户信息)页面加载的时候，判断是否已经授权。API.wechatRedirect:nodejs 对登录授权回调接口的实现主要是拿到客户端的请求参数，请求微信提供的当用户点击之后，会执行跳转。而这个接口也是node端实现的，具体内容如下：「注意」：上面的代码为了简单，删除了一些不必要的代码，如有兴趣，访问gitHub。同样，如果你没有阅读过微信H5开发的,建议你先阅读。关于分享，你应该阅读以下内容：当再次回调到页面的时候，从cookie已经拿到openId了。客户端会继续执行下面的代码。获取到服务端返回的配置信息，从而初始化分享的功能。在这之前，你需要util/index.js 里面对分享的功能进行了封装。nodejs端对接口的实现如下：以上代码主要获得基础的,然后用基础结合签名、时间戳、随机数等相关的参数，返回给客户端相应的参数。需要注意的是，和的区别。建议。到此，微信H5接入jssdk实现分享就已经完成了。小程序支付前端流程后端支付流程支付的主要逻辑在服务端下面把服务端的流程通过代码的方式表述出来。首先在util中封装了一些支付需要的公共方法下面是对支付的方法的封装，其中调用了util中的函数。客户端调用的就是下面的方法。最后定义的支付接口，里面调用公用的order方法。这里的流程请参见。官方描述的非常清楚，这儿就不描述更多了，其实主要就是拼接一些参数，获取。然后根据签名加上其他需要的(参见上述代码)再凭借xml的数据。然后再调用统一下单接口。生成之后，生成小程序端需要的一些参数，然后把这些参数返回个小程序客户端，供小程序的客户端调用微信小程序的支付功能。小程序前端支付非常简单，只是简单的调用服务端提供的接口，传入和即可。然后获取到相应的参数，调用微信提供的拉起支付即可。主要代码逻辑如下：到这里，小程序端的支付功能就已经实现了。"}
{"title": "微信小程序加入购物车动画的实现（向上、向下） ", "author": "Rolan", "time": "2020-1-14 00:42", "content": "场景描述：一般情况下，加入购物车的动画效果都会是上图的3的路线，在这篇文章里，我们来实现1和2路线的加入购物车的动效（3路线的动画效果网上有很多，具体可以参考这篇文章来实现：）。实现方式：不管是上图中的哪一种效果，我们都是用CSS3里的cubic-bezier（三次贝塞尔曲线）来实现的。具体什么是三次贝塞尔曲线，可以参考这篇文章：#实现流程：至此，流程全部介绍完毕，下面是全部的代码（里面可能有一些没用的css样式代码，读者可以自行根据需要删除）："}
{"title": "xquery小程序简易步进器 ", "author": "Rolan", "time": "2019-12-30 00:29", "content": "这样一个简单的组件，翻了ant.design才知道这种组件叫做步进器(steper)，步进器常用于购物车等需要增减数量的场景，最近的旅游项目中用于增减房间数和人数，从产品的角度来理解步进器很简单，但在开发角度来说需要适应多种场景及控制一些状态大致需求如上，demo及实现部分如下因为是直接使用Item组件实现，所以组件写在Page页面中，当然独立成组件看需求了"}
{"title": "uni-app微信小程序开发之引入腾讯视频小程序播放插件 ", "author": "Rolan", "time": "2019-12-17 00:01", "content": "正式开始使用腾讯视频小程序插件之前需先在微信公众平台 -> 第三方设置 -> 插件管理处添加插件，如下图所示：注意在使用uni-app开发微信小程序时与直接会用微信网页开发工具开发微信小程序是有很大的差别的，因为uni-app可开发多平台的原因，因此不同平台的开发相应的配置需要放到指定的位置才能够生效。而uni-app引入腾讯视频小程序有两种方式一种是整个小程序可使用（小程序中所有的分包可以使用），第二种是指定对应的分包可使用。使用插件之前需要在manifest.json中的mp-weixin内声明使用的插件，具体配置参照所用插件的开发文档：如果插件只在（同一个插件不能被多个分包同时引用）一个分包用到，可以单独配置到分包中，这样插件不会随主包加载，可以在的中声明插件：打开网页腾讯视频=>随便找到一个视频点击鼠标右键=>赋值链接地址（仅供参考）如下图所示：最后取视频连接地址.html前面的那一小串英文数字编号即可，下图所示："}
{"title": "红包小程序小结 ", "author": "Rolan", "time": "2019-12-30 00:33", "content": "最近做了一个红包兑换，遇到了一些问题这里做一下总结。1、需求：回流用户在游戏客户端获取到口令，然后在小程序这边输入口令兑换红包，成功之后钱会发到用户微信账户里。2、流程：若未授权，显示授权按钮。点击授权登录，授权成功后获取到私密字段iv和encryptedData，调取登陆接口，错误则提示相关信息，正确则跳转校验姓名和身份证的页面，校验通过就调取提现接口，成功则提示提现成功，同时显示生成分享图按钮。分享图由用户昵称，头像，二维码，提现金额等等组成。3、框架：uniapp1、获取宽度的时候，传入的参数如果是数字，则会返回0。2、绘制图片的时候不要忘了先使用转成临时地址，再，如果不经过这步，虽然开发者工具上看到是正常的，但是真机是显示不了。4、最初背景图大概170KB，尺寸750*1334，最终绘制出来的分享图太大了。解决方法：如图：如果用户点击确定，就会正常保存图片到本地相册了。如果用户点击取消，不授权呢？那还能怎么样，点击再弹出原来的弹窗重新授权呗。很遗憾，这里并不能像授权登录弹窗一样点了取消之后，再次点击授权按钮还会唤起那个弹窗。解决方法：在的fail回调函数里面操作，再次获取保存到相册权限。点击取消按钮之后，会跳转到这里。打开设置里的“保存到相册”的开关即可。针对此次项目，这里挑两点来写。1、原生微信小程序可以在app.js的globalData对象中对全局变量进行管理app.jspages/index/index.js2、uniapp用的是vue的那套，所以可以用vuex来管理状态设置获取1、原生微信小程序，比如在app.js中获取用户信息保存在中userInfo字段，然后页面在onload的时候获取全局的userInfo，你会发现有时候拿不到。由于 getUserInfo 是网络请求，可能会在 Page.onLoad 之后才返回，所以需要加入 callback 以防止这种情况。app.jspages/index/index.js2、uniapp是配合vuex和计算属性computed来处理的APP.vuepages/index/index.vue获取到便可以使用了，如果需要，还可以使用watch监听。"}
{"title": "从CSS角度来做一个模态框 ", "author": "Rolan", "time": "2019-12-30 00:42", "content": "今天我们从CSS角度来做一个下图这种模态框。先上代码：模态框背后的背景是一个fixed定位，四个方向都为0的view，主要是怎么实现中间弹窗的垂直水平居中，这里提供两个方案。这种方案是将弹窗设置绝对定位后，左边（上边）距设为50%，就是弹窗左上角距父级左上角的距离正好是父级的宽度（高度）的50%，就是在正中间，同时使用属性，将弹窗向左（上）移动自身宽度（高度）的50%，来实现弹窗正好在水平（垂直）方向都能居中。这种方案更简单，只需要将父级设置为flex布局的同时设置和都是就可以了。模态框弹出后，在父级上加上就可以阻止背后页面的上下滚动。"}
{"title": "Rax 转小程序链路原理解析（一） ", "author": "Rolan", "time": "2020-1-2 00:15", "content": "随着 1.0 版本的发布，在端的转换能力也得到了补齐。现在，你可以像过去开发 Web/Weex 端的应用一样使用 Rax 来进行小程序的开发。本系列文章将介绍 Rax 转小程序链路的实现原理。这是本系列的第一篇。首先，我们需要对小程序（如无特别交代，文中的小程序均指支付宝小程序）的开发方式有一定的了解。你可以查看对整个小程序体系框架有一个大概的认知。本文假定读者已对上述内容有所了解。为了明确转换链路要做的事情，我们以最简单的情况举例：在使用 Rax 开发项目时，单个组件的内容如下所示：经过处理后，该组件对应的小程序代码应当包含、和等三个同名文件（如有样式内容，还会多一个文件）。其中，会包含源文件中的业务逻辑，会与源文件中的 JSX 有所对应，而则需要包含源文件引入自定义组件（该示例中只引入了）的声明。Rax 转小程序链路做的就是以上的转换操作。当然，这只是简单的单个组件层面的转换，项目级别的构建会有很多复杂的问题需要考虑，下面我们将解析 Rax 转小程序链路在工程上的实现原理。先看一下整体的架构图：本文将介绍 CLI 和 loader 两个工程模块。把 CLI 和 loader 放在一起介绍是因为二者在功能上联系非常紧密。CLI 本身底层依赖 webpack 对项目进行依赖分析，然后调用 loader 层提供的各种 loader 对对应类型的文件进行处理。CLI 对外提供 watch 和 build 两个指令。前者用于监听代码变动并实时编译，后者相比前者会剔除部分调试用的代码（如 source map）并压缩代码，完成编译打包。具体到实现上，CLI 本身并不复杂，用一句话概括的话就是从命令行读取各种必要参数，然后传入 webpack 执行。利用 webpack 的依赖分析能力，我们能够遍历到所有有效代码并交由对应的 loader 进行处理。这里可能会有同学提出疑问，入口文件是什么样的，它又是如何声明依赖的？因为在小程序原生开发框架中，入口文件并没有声明依赖，而 pages 是在中注册的。下面就需要先介绍一下 Rax 小程序的工程目录。为了保持多端统一，Rax 采用同一套工程目录，当我们使用创建一个小程序项目时，其目录结构如下所示：中包含路由配置。其默认内容如下：CLI 将读取其中的内容并将所有引用到的 pages 文件以及作为 entry，类似于多页应用程序的配置。至此，以 pages 文件为入口，所有依赖文件将依次被遍历并交由对应 loader 进行处理。loader 处理完毕后最终的编译代码将生成到目的目录，而 webpack 默认生成的 bundle 对我们来说并不需要，我们将设置为内存文件系统使其不产出至磁盘上即可。jsx2mp-loader 中一共存在以下五个角色的 loader，分别用来处理对应类型的文件。下面将分别介绍其功能。一句话概括三种 loader 的主要功能就是读取对应类型的文件内容（app-loader 处理 Rax 源码中的 app.js，page-loader 处理定义在  app.json 中属性内的 page 类型组件，component-loader 处理 component 类型组件）并交由 jsx-compiler 处理然后产出编译后代码，并写入至指定目标文件夹位置。除此之外，每个loader 还有一些自己特定的职责：处理图片等静态文件资源，将其拷贝至指定目标文件夹。所有 loader 中任务最繁重的非 script-loader 莫属。script-loader 负责处理所有 js  文件。而对于 js 文件，有一个非常重要的需要考虑的问题就是依赖路径处理。在 Rax 转小程序链路中，我们默认采用将 node_module 中使用到的文件提取并拷贝至目标文件夹，这样做的原因基于以下两点：所以，依赖路径处理是 script-loader 最核心的功能之一，其基本工作流程是：搜集代码中使用到的 npm 依赖，获取 npm 包的真实地址 => 路径处理 => babel 编译 => 输出代码至目标文件夹。在 Rax 小程序项目中，对于来自 npm 包的纯 js 文件（比如 loadsh）或者用户自己编写的本地 js 文件（比如 utils 文件），执行以上流程即可。对于以下两种类型，除上述基本流程外，script-loader 还需要一些额外操作：用户使用绝对路径去使用第三方原生小程序库时，script-loader 需要读取 js 文件同目录下同名的 json 文件中的字段并将其加入 webpack 的依赖分析链关于多态组件（库）协议可以点击查看官网文档。 Rax 基础组件均基于该协议支持小程序端。实际上，通过使用绝对路径引入原生小程序组件使用完全可以满足需求，但是 Rax 定位于多端统一开发框架，这样做会使开发小程序端时产生平台特定的代码，无法真正做到一套代码多端运行，因此我们设计了多态组件（库）协议。用户在小程序端引入组件时可以正常如 Web/Weex 端一样边写代码如，但实际上由 script-loader 去读取 package.json 中字段的值以获取真实使用的原生小程序组件地址。基于多态组件（库）协议，用户可以方便地进行 Rax 小程序组件的构建与发布，然后在 Rax 项目中引入使用。本文阐述了与的基本原理，也梳理了 Rax 转小程序链路工程上的整体脉络。关于怎么处理编译以及是如何作了运行时的支撑并抹平了原生小程序组件实例与 Rax 实例的差异，敬请期待后面的文章。"}
{"title": "张小龙微信公开课PRO演讲：信息互联的7个思考 ", "author": "Rolan", "time": "2020-1-10 00:02", "content": "划重点：公开课的朋友们，大家好。又到了一年一度的微信公开课。很抱歉这次没有来到现场，在这里跟大家打个招呼。其实我是故意不来现场的。记得第一次公开课，我提到说，参加各种会议可能是很浪费时间的。我还说过，用产品说话，才是我们应该做的。大家也看到，微信从来没有开过发布会。我认为，新版本的启动页，就是微信的发布会，它直接覆盖几亿用户。但同事们说服我说，公开课不是发布会，而是面向开发者的会议。确实，外界可能也会对微信有好奇甚至误解，所以公开课确实是一个微信对外阐述自己想法、理念的一个很好的机会。但去年，我就想，微信团队现在这么大了，我们面临的问题，从早期的“怎么做”，到现在的“做什么”。早期我们聚焦于每一项功能，思考怎么做才是最完美的。现在是思考，什么才是我们应该去尝试的，以及如何组织起来做。对团队来说，早期是考验我们的产品能力，现在更考验的是我们的组织能力。我希望我们团队，在每一个领域都有杰出的深入的思考者。所以去年，我就在想，我不一定每年都来公开课讲。今年，我更乐意把时间让给我的同事们，让他们来给大家带来我们团队的思考。当然，我个人也有一些小的思考点，可以在这里分享给大家。可能从来没有一个时代，每天有数亿人花这么多时间，花在手机里面浏览各种信息。而微信，可能是人们花时间最多的应用。所以我也经常会思考，微信作为一个基础的信息传递的工具或者说平台，我们一个不经意的动作，可能会引起信息洪流的流向的变化。我们知道，基因编辑是一种非自然的选择。因为人类强行的改变了自然进化的进展。类似的，技术的进步同样改变了自然的选择。人们看到屏幕上的视觉信息，超过了现实中眼睛看到的信息。人们看到的是远方的图像，听到的是远方的声音。从前一个人的世界，他的大小，是由他的脚的行走半径来决定的，现在一个人的世界的大小，是由他所获得的信息的宽广度来决定的。信息的宽广度和质量，一直是微信要解决的问题。但人类对于信息的广泛连接带来的影响的思考，是落后于网络的发展速度的。网络的发展，尤其是最近几年移动互联网的发展，使得人人都随时在线，并且面临海量的信息。这在历史上，甚至十年前，都是难以想象的。人们真的能驾驭这种信息互联吗？还是说，技术在引导甚至控制人们的生活方式？可以从几个维度来看一看这种影响，包括隐私的出让，信息获取的被动，社会关系的扩大和复杂，信息传播的快速，信息选择的困难、信息的多样性，搜索的困难。从历史来看，科技越发达，个人隐私会越少。人们在获取便利性的同时，其实也在不知不觉地一点一点把自己的隐私范围缩小。比如精准广告和用户隐私其实是有矛盾的。作为平台，因为我们有大量的数据，什么该用，什么不该用，其实是我们一直思考的问题。我们在这里也倡导同行一起重视这个问题。你所看见的，或者说，你所阅读的，决定你是什么样的人，会有什么样的想法。互联网让信息唾手可得。可是，从信息的海洋中获取什么样的信息是个很有挑战的问题。事实上，很多人并不愿意主动去获取信息，而是更倾向于被动获取。记得好几年前，我说过一句话，“推送改变世界，因为用户更懒了”。包括微信，也是基于推送的。你收到的每一条消息，都被你把优先级排得比你要真正要获取的信息的优先级要更高一些。那么，推送什么信息，决定了用户会看什么信息，决定了他在一个什么样的世界里。这是一个我们要经常思考的问题，也是我们在努力的方向。所以，我很少说分发这个词，我觉得推荐可能更尊重一些。人是社会关系的总和。而如今，社会关系越来越多地体现在微信好友，群，朋友圈的互动里面。比如，中学、大学同学，因群而活跃起来。过去，学术上有个词，叫邓巴数，是说一个人最多有150个好友。但在微信里，显然它被打破了。人们对于好友的维系能力，和移动互联网之前的年代相比，突然增大了很多。之前我们限定一个人最多5000个好友，现在有将近一百万人已经接近5000好友。虽然不是真正意义上的好友，但也促使我们要扩大好友数目了。我记得附近的人上线时，我自己其实都有隐隐的不安，因为从前我们和附近的人的界限将被打破，我不知道它是好是坏。这种思考，其实会一直贯穿在微信的进化里面。就像我们扩大5000好友这个限定非常容易，但是对于它带来的影响，说实话诚惶诚恐，我们会反复思考。一方面，是信息比之前更快速地传播，可能一个瞬间，一个事件就可以迅速在很多个群里面，迅速的几何级数的传播。另一方面，有一句话叫“谣言传千里”，耸人听闻的内容，可能能获得更大的传播机会。这是人性使然。我们可能很难用技术手段作为一个判定内容的质量的标准，但作为信息传递的平台，我们也有很多办法，譬如说用更多的参与者和强大的机制，来帮助平台作出仲裁，就像我们对待原创和抄袭的做法很类似。看似我们面对海量信息可以自由选择哪一些看、哪一些不看，但事实上，我们不可能有时间去一一筛选，导致我们看到的总是局部。包括公众号，看似可以随便关注，但是你的选择其实是有限空间的。我们在看一看里实验了社交推荐，看起来效果还不错。它是一种通过好友之间的互相推荐来扩大人的选择范围。虽然头部大号会有最大的浏览量，但是在一个人人皆可创作的年代，我们希望长尾的小号都有自己的生存空间。这也是之前公众号一个忽略了的部分。等一下会再讲一下。与web互联网相比，移动互联网的各个app更加割裂，信息难以打通、搜索。我们做，就有一个梦想，希望搜索能进入到每一个小程序的内部，这样海量的小程序可以支撑起各种长尾的搜索需求。当然，小程序仍然是我们一直要改进的领域，只有小程序足够繁荣，才能支撑起搜索的内容的丰富度。这里讲了我们对于信息普及、对于生活的影响，其中提到信息的多样性。这里也要说一下。在微信的起步阶段，我就说过，我们基于手机来做app，不基于pc来做。pc端只是辅助。如果不是这样的话，我们没有办法将我们的产品普及到每一个人都能用。回过头来看，我们当年有两个小小失误，一个是，公众平台。很长时间都只有pc web版，这限制了内容创作者的范围。另一个是，也是更重要的，公众平台的原始想法是取代短信成为一种基于连接品牌和订户的群发工具，并且有效地避免垃圾短信。群发的内容并不是重点，应该是各种各样的形式的内容都应该是可以的，如文字，图片，视频等。但我们一不小心把它做成了文章作为内容的载体，使得其他的短内容的形式没有呈现出来，那使得我们在短内容方面有一定的缺失。这也是为什么之前我说，公众号本身并不是为媒体准备的这样一个原因。我们很重视人人都可创造的内容。朋友圈之所以默认是发照片视频的，是因为当时我有一个认知，对于十亿人来说，让每个人发文字是不容易的，但是，发照片是每个人都可以做到的。所以，相对公众号而言，我们缺少了一个人人可以创作的载体。因为不能要求每个人都能天天写文章。所以，就像之前在公开课所说的一样，微信的短内容一直是我们要发力的方向，顺利的话可能近期也会和大家见面。毕竟，表达是每个人天然的需求。所以这里，也是作为一个对新版本的小预告吧。春节即将到来，我们在红包上，也有一些新的创造，可能也会吸引你来发挥你的创造力，这里也预告一下。今天我的分享就到这里。虽然这次我没有参与现场的演讲，但是我相信我的同事们同样会给你带来精彩的报告。再次感谢大家。"}
{"title": "微信小程序实战教程——2实战之模仿知乎 ", "author": "Rolan", "time": "2019-6-25 00:42", "content": "除了项目中自带的文件夹，我引入了几个新的文件夹：接下来我以首页为例进行分析，其他页面也都类似。建议能力较强的小伙伴先把下载下来，自己先尝试着根据效果图实现代码，做完之后再回来看与我的思路有哪些不同。这个页面中每一条记录都是相同的，所以可以抽象为一个组件，在components文件夹下面创建一个组件，wxml与wxss比较简单，不做过多讲解。子组件需要监听两个事件，分别为触摸该子组件时跳转到该问题的回答的详情页面以及触摸右上角的三个点跳转到该问题的详情页面。第二个事件触发的同时会冒泡并触发第一个事件，所以监听第二个事件的时候需要采用catch前缀监听并阻止事件冒泡。完整代码如下。抽象出子组件并不难，难的是如何设计子组件与父组件的粒度大小，在上面的例子中子组件监听了触摸事件，这时候是由子组件执行wx.navigateTe()还是由父组件执行，这才是我们最需要考虑的问题，我的想法是子组件只控制样式的变化，不执行业务逻辑，业务逻辑我一律交给父组件来做。下面代码参考分析首页可以得知，每条记录需要一个id、标题、作者头像、作者名、正文内容、点赞的数量以及回复的数量。在Mock文件夹下创建一个indexMock.js文件专门为首页提供虚拟数据。微信小程序提供了wx.request()接口发送网络请求，这是十分常用的API，封装后我们可以省去很多的代码量。在utils文件夹中创建一个HTTP.js文件，在这里对wx.request进行一次封装现在我们发送一个AJAX只需要传入url、data、method为GET时可以省略、success方法以及error方法。仍然需要传入很多参数，这时候可以对每一个具体的AJAX请求做一个封装。在models文件夹中创建首页发送AJAX的文件indexModels.js，在这其中对首页使用到的AJAX请求进行第二次封装。在页面中引入indexModels.js文件后new一个类即可调用getIndexListByMock方法，此时只需要传入data与success方法。使用Mock之后总是要切换回真实数据的，这时候在页面中的每一个AJAX请求都需要更改，太过繁琐，这时可以考虑引入一个全局常量，只修改这个常量即可实现Mock数据切换为真实数据。在最外层创建一个config.js文件，定义一个常量用于控制数据来源是Mock数据还是真实数据。在indexModels.js文件中引入config.js，使用常量DEBUGGER来判断使用哪个来源的数据，indexModels.js改变为：之后需要改变数据来源为真实数据时，只需要在config.js中将DEBUGGER改变为false即可。至此，这个页面就已经写完了。"}
{"title": "从客户端角度窥探小程序架构 ", "author": "Rolan", "time": "2020-1-7 00:42", "content": "自诞生以来。就以一种百家争鸣的姿态展现在开发者的面前。继2017年1月9日微信小程序诞生后，小程序市场又陆续出现了支付宝小程序、头条小程序、百度智能小程序等等，甚至平安内部，也在发展自己的小程序生态。各家都在微信小程序的基础上，面向自己的业务，对架构进行逐步优化调整，但是万变不离其宗，微信小程序终归为小程序鼻祖，也是得益于微信小程序的思想，才造就了如今这百花齐放的业态。说起微信小程序，在体验上的优化，让我很长一段时间认为，这是 Native 层渲染。事实并不完全是，至今不敢相信，webView 的渲染竟能带来如此体验。本篇主要以一个客户端开发者的角度，来对微信小程序、支付宝小程序一探究竟。本篇旨在原理分析，我并未有真实的小程序架构设计经验。说到小程序，不得不需要指出另外一个问题，苹果爸爸的审核问题，目前会有开发者存在这样的疑问，Hybrid 和 H5 是不是要被苹果拒审了呢？其实从更新描述来看，不难发现苹果的主要目的是针对的 App ，实际上小程序无论是在设计理念上，还是核心技术上，都不存在这样的问题，小程序并非App，小程序是以 App 为载体，尽可能的对 web 页面进行优化而生成的产物。还有一点是日益猖獗，马甲包最后基本都转化成为了条款内描述的类型，所以苹果想要尽可能的禁止它。而且从微信小程序开发文档来看，微信小程序是典型的。关于RN类技术，更不存在这样的问题了，RN本质为 JS 通过 JSCore 调用 Native 组件。实际上它的核心仍然在 Native 端，当然对 code push 我还尚存疑问。关于 RN 的动态更新上，从的描述也不难发现苹果爸爸的态度，。微信小程序是什么，微信把小程序定义为是。便捷和出色有何而来？小程序技术最初来源于 H5 和 Native 间的简单调用，微信构建了一个 WeixinJSBridge 来为H5提供一些 Native 的功能，例如地图、播放器、定位、拍照、预览等功能。关于 Bridge 的具体实现可以参考之前的文章。但是微信逐渐的又遇到了另外一个问题，那就 H5 页面的体验问题，微信团队为了解决 H5 页面的白屏问题，他们引入了最近很火的概念，当然微信称之为，实际上是一个东西。Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页的加载时间。关于离线包的概念，不了解的话可以参考下我之前的文章。但是当页面加载大量 CSS 和 JS 时，依然会有白屏问题，包括 H5 页面点击事件的迟钝感和页面跳转的体验问题。那么基于此问题，应运而生的，小程序技术就诞生了。从微信小程序的发展史，不难看出，小程序实际上是近几年开发者对 H5 体验优化而来的，这也切合了前面所说的，。微信小程序自称能够解决以下问题：快速加载和原生的体验，这其实都是在体验上的升级，更强大能力实际上源于微信小程序为开发者提供了大量的组件，这些组件有基于web技术，也有基于Native技术，在我看来这和 RN 技术不谋而合。后面我会举一个模仿 RN 实现的小例子来阐述一下它的原理。高效和简单的开发是因为微信小程序开发语言实质上还是基于 web 开发规范，这使得开发前端的人来开发小程序显得更容易。还有一点更重要的就是安全，为什么说小程序是安全的？后面会逐步展开，揭开小程序的神秘面纱。小程序的架构设计与 web 技术还是有一定的差别，吸取了 web 技术的一些优势，也摒弃了 web 技术中体验不好的地方。最主要的特点就是小程序采用双线程机制，即视图渲染和业务逻辑分别运行在不同的线程中。在传统的 web 开发中，网页开发渲染线程和脚本线程是互斥的，所以 H5 页面中长时间的脚本运行可能会导致页面失去响应或者白屏，体验糟糕。为了更好的体验，将页面渲染线程和脚本线程分开执行：双线程模型是小程序框架与大多数前端 web 框架的不同之处，基于这个模型可以更好的管控以及提供更安全的环境。因为逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。客户端的开发者可能对 DOM 有些陌生，了解编译过程的同学应该知道在编译器编译代码的时候，会有一个语法分析的过程，生成抽象语法树 AST，编译器会根据语法树去检查表达式是否合法、括号是否匹配等。实际上DOM也是一种树结构，经过浏览器的解析，最终呈现在用户面前。通过 JavaScript 操纵 DOM 可以随意改变元素的位置，这对于小程序来说是极为不安全的。所以说逻辑层为小程序带来的另一个特点，易于管控和安全。线程通信基于前面提到的 WeixinJSBridge ：逻辑层把数据变化通知到视图层，触发视图层页面的更新，视图层把触发的事件通知到逻辑层进行业务处理。当我们对渲染层进行事件操作后，会通过 WeixinJSBridge 将数据传递到 Native 系统层。Native 系统层决定是否要用 Native 处理，然后丢给 逻辑层进行用户的逻辑代码处理。逻辑层处理完毕后会将数据通过 WeixinJSBridge 返给 View 层，View 渲染更新视图。根据描述，。大概可以理解为，每个 web 页面都是运行在单独的 webView 里面，这样的好处就是让每个 webView 单纯的处理当前页面的渲染逻辑，不需要加载其他页面的逻辑代码，减轻负担能够加速页面渲染，使其能够尽可能的接近原生，这与小程序跳转页面的体验上也是一致的。实际上在小程序源码内有一个文件的存在，这是小程序启动后的入口文件。初次加载的时候，主入口会加载相应的 webView ，这其中就会包括前面所提到的，视图层和逻辑层。逻辑层虽然也提供了 webView ，但是并不提供浏览器相关接口，而是单纯的为了获取当前的 JSCore ，执行相关的 JS 脚本文件，这也是开发小程序是没办法直接操作 DOM 的根本原因。当我们每打开一个新页面的时候，调用 navigateTo 都相当于打开了一个新的 webView ，这样一直打开，内存也会变得吃紧，这也是为什么小程序对页面打开数量有限制的原因了。根据小程序开发文档描述：。这在客户端的角度来看，相当于打开新页面之后，对下一个页面的 webView 提前做了预加载，这个思路与当前比较流行的 webView 缓存池的思路不谋而合，原因是在 iOS 和 Android 系统上，操作系统启动 webView 都需要一小段时间，预加载会提升页面打开速度，优化白屏问题。再往深层次来看，通过小程序开发工具的源码，能找到一个的模版文件，具体位置在：看标题就应该很清楚了，这是渲染层的核心模块，它的作用就是为小程序准备一个新的页面，小程序每个视图层页面内容都是通过 pageframe.html 模板来生成的，包括小程序启动的首页。通过查看源码，里面定义了一个属性，我猜想这是每个 webView 页面的页面 ID ，逻辑层处理多个视图层间的业务逻辑可能就是通过这个ID来做的映射关系。在首次启动时，后台会缓存生成的 pageframe.html 模版，在后面的页面打开时，直接加载缓存的 pageframe.html 模版，页面引入的资源文件也可以直接在缓存中加载，包括小程序基础库视图层底层、页面的模版信息、配置信息以及样式等内容，这样避免重复生成，快速打开页面，提升页面渲染性能。关于 pageframe.html 最后是怎么生成相应页面的归功于一个叫 nw.js 的框架，具体实现这里就不讲了，更多的偏向于前端的知识了。上面了解了渲染层都做了什么之后，下面在窥探一下，小程序的逻辑层都做了什么。参考不难发现，sevice 层的代码是由 WAService.js 实现的，逻辑层实际上主要提供了 Page， App，GetApp 接口和更为丰富 wx 接口模块，包括数据绑定、事件分发、生命周期管理、路由管理等等。关于视图层和逻辑层间的具体交互细节可以看下这张图：我们写的页面逻辑最后都被引入到了一个叫 appservice.html 的页面中，并且分别从 app.js 开始一一执行；小程序代码调用 Page 构造器的时候，小程序基础库会记录页面的基础信息，如初始数据（data）、方法等。需要注意的是，如果一个页面被多次创建，并不会使得这个页面所在的JS文件被执行多次，而仅仅是根据初始数据多生成了一个页面实例（this），在页面 JS 文件中直接定义的变量，在所有这个页面的实例间是共享的。对于逻辑层，从客户端的角度看，我们应该更关注于逻辑层的JS是怎么注入到JSCore中的。说到JavaScriptCore，我们先来讨论下Hybrid App 的构建思路，Hybird App是指混合模式移动应用，即其中既包含原生的结构又有内嵌有 Web 的组件。这种 App 不仅性能和用户体验可以达到和原生所差无几的程度，更大的优势在于 bug 修复快，版本迭代无需发版。Hybird App的实质并没有修改原 Native 的行为，而是将下发的资源进行加载和界面渲染，类似 WebView。下面通过一个例子来模拟一下 avaScriptCore 执行 JS 脚本来让 Native 和 JS 之间的通信。关于 JavaScriptCore 的具体使用可以参考下戴铭的。我们打算实现这样的功能：通过下发JS脚本创建原生的 UILabel 和 UIButton 控件并响应事件，首先编写 JS 代码如下：创建一个 OC 类 TestBridge 绑定到 JavaScriptCore 全局对象上：在 ViewController 中实现一个界面渲染的 render 解释方法：这样就完成了一个简单的 JS 脚本注入，实际上执行后的样子是这样的：这就是一个简单的执行 JS 脚本的逻辑，实际上 ReactNative 的原理也是基于此，小程序逻辑层与微信客户端的交互逻辑也是基于此。到这里，关于微信小程序渲染层与逻辑层做了什么、怎么做的、优化了什么以及为什么要采用这样的架构来设计，基本都梳理完毕了。小程序这样的分层设计显然是有意为之的，它的中间层完全控制了程序对于界面进行的操作， 同时对于传递的数据和响应时间也做到的监控。一方面程序的行为受到了极大限制， 另一方面微信可以确保他们对于小程序内容和体验有绝对的控制。我们在小程序的 JS 代码里面是不能直接使用浏览器提供的 DOM 和 BOM 接口的，这一方面是因为 JS 代码外层使用了局部变量进行屏蔽，另一方面即便我们可以操作 DOM 和 BOM 接口，它们对应的也是逻辑层模块，并不会对页面产生影响。这样的结构也说明了小程序的动画和绘图 API 被设计成生成一个最终对象而不是一步一步执行的样子， 原因就是 json 格式的数据传递和解析相比与原生 API 都是损耗不菲的，如果频繁调用很可能损耗 过多性能，进而影响用户体验。总结一句话就是。后面再简要的分析下支付宝小程序，支付宝小程序属于后起之秀，支付宝小程序在微信小程序的基础上，做了一些优化，单从技术角度来看，有点后来者居上的意思。目前支付宝技术通过官方的媒体账号对外暴漏的一些实现细节也在逐步增多。这段文字来源于支付宝对外开放的技术博客的描述，从这段描述中，我们能够发现支付宝小程序在架构设计上同样采用的渲染引擎加 JavaScript 引擎两部分，包括页面间的切换实际上和微信小程序逻辑基本一致。下面这张是支付宝小程序应用框架的架构图：单从这个运行时架构来看，它与微信小程序不同的地方是，webView 页面也就是渲染层通过消息服务直接与逻辑层进行通讯，而不需要像微信的 JSBridge 那样作为中间层，消息服务具体实现细节目前尚不得知。支付宝的JSBridge只会与逻辑层进行通讯，来给小程序提供一些 Native 能力。支付宝的这种架构主要目的是解决渲染层与逻辑层交互的对象较复杂、数据量较大时，交互的性能比较差的问题。支付宝小程序的设计思路比较值得借鉴，微信小程序线程间的通讯是通过 JSBridge ，序列化 json 进行传递的。支付宝小程序重新设计了V8虚拟机，让逻辑和渲染都有自己的 Local Runtime，存放私有的模块和数据。在渲染层和逻辑层交互时，setData 的 对象会直接创建在 Shared Heap 里面，因此渲染层的 Local Runtime 可以直接读到该对象，并且用于 render 层的渲染，保证了逻辑和渲染的隔离，又减少了序列化和传输成本。当然支付宝还有些其他的优化，包括首页离线缓存，缓存时机的处理以及闪屏处理等等问题，这里就不再延伸讨论了（因为很多细节我也不知道）。根据支付宝小程序对外开放的技术文章来看，架构设计还是非常巧妙的，也很值得我们学习，先看图：小程序SDK在架构设计上把它分为了两部分，一部分是核心库基础引擎，一部分是基于基础库开发的插件功能。从上往下看：差不多半年多没有写文章了，趁着公司年会时间稍显充裕，对当前的小程序架构进行了下分析和总结，当然，真正的小程序应该比这还要复杂的多，小程序实际上是多年来大前端融合的一个结果，是一套非常成体系的技术方案，看了这么多我想你对小程序也有了初步认识，小程序的核心实际上还是和的构建，那么如果让你开发一套，你会怎样设计它们呢？"}
{"title": "小程序的getElementsById，就像一把梭 ", "author": "Rolan", "time": "2019-12-24 00:52", "content": "使用selectComponent可以抓取自定义组件实例对象，但在层层嵌套结构的业务场景中，id的设置繁复，js/wxml开发界面频繁的切换，查找、维护、调整的开发工作很是让人抓狂啊好想封装一个getElementsById方法给，像在web开发中那样能够方便的获取页面元素。在父子子子子级间轻松调用，好想念jquery开发的一把梭时代！实现如下需求：实现不难，我们可以将所有自定义组件在create生命周期方法时将挂载到一个全局变量中，生命周期时销毁该实例(不然爆内存)一个全局的挂载、销毁方法，方便将实例对象注册、注销在app._elements上定义全局在Page中能够方便调用ui-component组件下面开始在Page中使用来抓取自定义组件实例wxmljs至此，基本思路已经实现，现在即兼容了selectComponent方法，又简化了写模板id的麻烦。不知道大家有没有了解小程序组件是可以递归嵌套自己的(模板不能递归嵌套)。因此聪明的你应该可以想到通过数据嵌套去实现组件嵌套，进而实现结构嵌套，这样我们就能够实现很复杂的页面结构，当然小程序目前建议是结构应该在30层左右，然并卵，反正它能够正常显示，哈哈"}
{"title": "小程序入门看这篇就够了 ", "author": "Rolan", "time": "2019-11-7 00:10", "content": "文章为实战中踩坑经历，以及解决方案。同时是自己的一个项目回顾，在这里分享给大家，希望能帮助到大家，如果觉得文章对你有用，请点个赞:+1:，谢谢！原谅我也是个标题党：）授权（基本信息，手机号码 ）必须使用原生的的button组件，然后指定open-type 后通过回调才能拿到用户信息。代码入下：路由跳转的各个方法可以去官网学习，这里提遇到的坑，navigateTo路由跳转最多只能10层，所以使用的时候需要考虑是不是确定需要历史记录。为什么要这么说呢。 场景：一个列表页面（如下图），用户的档案是可以修改的，如果用navigateTo跳转（/page/archivesEdit?id=1923XXXX）,修改保存用navigateTo（/page/archivesList），这样来回编辑跳转10次就不让点击跳转了。解决：思考那我用2个redirectTo 行不行？redirectTo是关闭当前历史记录跳转到下一页面。造成了我跳转到修改页面点击微信自带的返回是直接跳过列表页面跳转到首页。这个时候测试小姐姐就又要提bug单了。。。完美姿势： 就是用navigateTo和navigateBack。我再编辑保存的时候返回用navigateBack返回。这样小程序的路由栈就一会在2-3层之间。当然有时候在列表页面会遇到要重新条用接口，这时候路由跳转提供了几个重要的钩子函数onShow，onHide，我们可以在onShow的时候可以条用一下列表的接口。这2个钩子函数足够我们简单的跳转，更复杂的场景下可以通过存Storage这种存取参数来返回到上一个页面进行操作，感觉不是优雅，但是没有好的办法解决了。场景：storage有2种方式获取，当你直接wx.getStorageSync('xxx')获取一个id，去请求接口的可能是获取不到就已经发送请求了，导致出现bug。因为wx.getStorageSync('xxx')是异步的 我们可以利用 async/await去方便的使用webview不是在某个页面使用的，当时我以为是类似iframe这种东西嵌入到页面。正确的使用态度是新建一个page页面，然后跳转到这个page去使用。例如跳转到小程序关联的公众号文章：微信自带的网络下的request，虽然能拿来就用，如果不封装就会造成代码冗余。大家可自行参考如下封装直接通过初始化的微信小程序项目里面没有package.json文件。所以在使用npm install xxx 是没有卵用。所以我们要自己在文件夹根目录下执行npm init 。这时候才能通过微信开发者工具构建npm，构建成功会生成一个目录。推荐用有赞的vant小程序版,社区较活跃，使用起来不会有很多坑。对于习惯使用vue的开发者来说，少了这个v-model语法糖。在处理表单的双向绑定会显得比较蛋疼。所以还是有必要说下小程序里面的双向绑定是怎么样的。这里场景是下载一个固定的静态资源图片，网络图片需先配置download域名才能生效,方法如下：保存图片也是需要授权的，看代码就完事了。textarea 在ios上表现会有padding值。我曹 这个就坑了。我采用要不全是textarea或者全是input 这种去实现表单的填写。 其他样式问题也蛮多的，有点ie的味道。:smiley:！！ 多用flex float去解决一些差异吧~文章每个点都是开发小程序的时候遇到的问题，本人能力有限，欢迎大家提出自己的问题，也可以加入微信群和我们团队一起交流学习。小程序坑还是蛮多的，而且写博客也蛮难得，码子不易，点个赞吧！ :）逃~~~~~"}
{"title": "kbone，十分钟让 Vue 项目同时支持小程序 ", "author": "Rolan", "time": "2019-11-8 00:48", "content": "微信开发过程中，许多开发者会遇到 小程序 与 Web 端一起的需求，由于 小程序 与 Web 端的运行环境不同，开发者往往需要维护两套类似的代码，这对开发者来说比较耗费力气，并且会出现不同步的情况。为了解决上述问题，微信小程序推出了同构解决方案来解决此问题。那么，要怎么使用呢？这里我们将通过一个的例子来跟大家讲解。首先，我们来看下一个基本的 kbone 项目的目录结构（这里的是基于的示例，也有，，等版本，详情可移步）。因为 kbone 是为了解决 小程序 与 Web 端的问题，所以每个目录下的配置都会有两份（小程序 与 Web 端各一份）不管是 小程序 端还是 Web 端，都需要入口文件。在目录下，为 Web 端用主入口，则为 小程序 端用主入口。当然，Web 端会比 小程序 多一个入口页面，即（位于根目录下）。下面两段代码分别是 小程序端 入口与 Web 端入口的代码，可以看到 小程序端的入口代码封装在函数里面（这里固定即可），内部会比 Web 端多一个创建节点的操作，其他的基本就是一致的。在上面的入口图可以看到，源码目录中，除了入口文件分开之前，页面文件就是共用的了，这里直接使用 Vue 的写法即可，不用做特殊的适应。写完代码之后，我们要怎么跑项目呢？这时，配置就派上用场啦。Web 端配置为正常的 Vue 配置，小程序端配置与 Web 端配置的唯一不同就是需要引入插件来将 Vue 组件转化为小程序代码。接着，我们需要构建代码，让代码可以运行到各自的运行环境中去。构建完成后，生产代码会位于 dist 目录中。小程序端 的构建会比 Web 端的构建多一个步骤，就是 npm 构建。进入目录，执行安装依赖，用开发者工具将目录作为小程序项目导入之后，点击工具栏下的，即可预览效果。最后，我们来看一下 todo 的效果。kbone 初体验，done~todo 代码可到自提。如果你想了解更多 kbone 相关的使用及详情，可移步。"}
{"title": "阿拉丁发布2019年小程序年度生态白皮书：小程序互联网时代到来 ... ", "author": "Rolan", "time": "2020-1-3 00:18", "content": "速途网1月2日消息（报道：吴佳馨）今日，阿拉丁统计平台和阿拉丁指数共同发布了2019年小程序互联网发展白皮书。白皮书显示，微信生态里，有超过150万小程序开发者，2019年微信商业化生态不断升级，一码一物能力上线；搜一搜品牌官方区全新升级；小程序模板消息能力调整；小程序支持AR效果等为用户带来了许多有温度、有价值的服务，同时小程序数据也一路猛增。用户方面，过去一年，社交裂变加“巨”粉丝群体体量，小程序矩阵催“升”用户粘性，小程序人均停留时长保持持续增长态势，用户对小程序的使用习惯已经形成，访问集中早7点至晚22点高峰时段，根据报告显示，30-39岁的用户占比最多为27.4%，而生活服务、网络购物、工具、视频与游戏类小程序在不同年龄用户群体都被广泛应用。随着微信小程序市场的不断开发，用户规模和渗透率的逐渐提升，2020年微信小程序数据的增长态势将会势不可挡。据本次报告预测显示2020年微信小程序数量将会达到500万、DAU将会达到4.5亿、小程序用户人均单日使用时长有望突破1500秒。"}
{"title": "微信小程序实战教程——1.基础知识 ", "author": "Rolan", "time": "2019-6-25 00:32", "content": "微信的语法与vueJS类似，没学过vueJS的同学尽量先过一遍vue再看本教程。首先在微信平台中注册一个账号获得开发者AppID，如下载微信小程序的开发者工具，安装完毕后打开开发者工具创建一个项目，将项目名称位置AppID填入即可。微信小程序的文件有四类，分别是.wxml文件，.wxss文件，.js文件，.json文件。 其中.wxml对应.html文件，.wxss文件对应.css文件，.json文件是配置文件。pages文件夹中每一个文件夹代表一个页面，新建的项目有两个页面，分别四index和logs页面，每个页面包含一个.js文件，一个.wxml文件，一个.wxss文件以及一个.json文件。四类文件的作用稍后会讲到。utils文件存放的是工具类，这个文件夹是非必须的，可以直接删掉。project.config.json与sitemap.json初学者可以暂时不理会。.wxml文件类似我们写的.html文件，但标签上有些不同。使用<view></view>标签代替<div></div>，使用<image></image>代替<img/>，使用<block></block>标签代替<template></template>，引入<text></text>标签等等，后续做项目的时候会了解到更多标签。.wxss文件就是.css文件。在app.wxss中控制全局样式，在pages文件夹中的页面文件的.wxss文件中控制局部样式。局部样式的优先级大于全局样式。微信小程序推荐的布局方式是弹性布局（）,使用弹性布局可以很快速的搭建我们的项目。微信小程序为了适配多种不同屏幕大小的设备，采取了一种的响应式单位rpx，使用rpx单位就好像使用百分比作为单位一样实现响应式布局。rpx是一种相对大小，我们使用iphone6的机型时，1px=2rpx，iphone6的大小为375px*667px，对于的rpx为750rpx*1334rpx。关于rpx的更多了解见wxss.html#尺寸单位.json文件是项目的配置文件pages是存放所有页面的数组,每一个使用到的页面都需要写入pages内，不需要写文件后缀，window属性配置的是状态栏的样式，如navigationBarBackgroundColor用于设置背景色，navigationBarTitleText设置状态栏显示的文本，navigationBarTextStyle设置状态栏文本的颜色，只能传入black/white，除此之外还可以配置底部导航栏tabBar等等。app.json文件进行全局配置，每个页面文件夹下还有一个.json文件用于局部配置，局部配置只能配置window属性注意事项小程序的生命周期分为应用声明周期和页面生命周期，应用声明周期函数在app.js中定义，且在小程序运行过程中一直存在内存中处于运行状态，在这里可以定义应用声明周期函数以及定义全局变量。每个页面中的.js文件中则可以定义页面声明周期函数等，语法类似vueJS。小程序为了提高性能，是不允许开发者操作DOM元素的。小程序中常用的指令有wx:for、wx:if、wx:elif、wx:else等。wx:if、wx:elif、wx:else的逻辑等同于if else。wx:for即循环生成标签。小程序中不使用click事件，而用tab（触摸）事件代替，事件的前缀有两种分别是bind和catch，bind:tab表示冒泡事件，即事件触发后继续冒泡触发后续事件，catch:tab表示非冒泡事件，即事件触发后不再冒泡，类似执行了event.stopPropagation()方法。改变data中的属性值必须使用this.setData()方法，传入一个对象，对象中存放需要改变的属性键值对。bind:tab可以简写为bindtb，个人喜欢bind:tab，看起来更清晰对于一个js文件，函数就是一个最小的、可复用的代码片段。而组件就是对于一个项目最小的、可复用的代码片段，他包括html、css、js代码，如我们常见的页面导航栏就可以做成一个组件，通过组件名字来使用，而不用将导航栏的代码复制粘贴到每个页面中。小程序的组件通过Component方法声明声明完毕之后，在需要使用到该组件的页面中进行调用首先我们看一下使用组件内部变量的例子，我们定义了userName变量并把它渲染到页面当中。接着我们接受一个外部的变量并把它渲染到页面上，这样就实现了父组件向子组件传值。子组件向父组件传值的思路一般都是父组件监听一个自定义的事件，子组件触发这个事件同时将值传入，父组件监听这个事件的时候就可以拿到子组件传过来的值。前面我们说到了可以在app.wxss中定义全局样式，每个page页面都可以继承全局样式。但组件不同，组件只能继承有关字体以及color的样式，其他全局样式不能影响到组件的样式。小程序的声明周期分为整个应用的声明周期以及单个页面的声明周期，对于初学者来说这部分内容可以先跳过，它就像一幅眼镜，你自然会知道什么时候需要。在app.js中调用的App函数中，可以设置应用声明周期的回调函数<image>标签中，不管图片多大，默认的图片大小宽度为300px,高度为225px，所以一定要给图片设置宽高。html页面中最外层的元素为<html>，小程序中的最外层元素为<page>，且<page>不需要自己添加啊，小程序自动添加的。<text></text>标签中默认不能识别&nbsp;&lt;&gt;等转移字符,设置decode属性即可识别这些转移字符。VueJS中使用v-if控制元素是否渲染，使用v-show控制元素是否显示。微信小程序中也有对应的操作，使用wx:if控制元素是否渲染，使用属性hidden控制元素是都显示。"}
{"title": "小程序跨页面交互的作用与方法 ", "author": "Rolan", "time": "2020-1-7 00:24", "content": "去年年末，微信的分包大小已经到达了 12M 大小,一方面说明小程序的确逐步为开发者放开更大的权限，另一方面也说明了对于某些小程序 8M 的大小已经不够用了。我个人今年也是在开发一个 to B 小程序应用。这里列举一些跨页面交互的场景。对于 B 端应用的业务需求来说，小程序开发的复杂度相对比网页开发要复杂一些。一个是双线程的处理机制问题，另一个是页面栈之间交互问题。注: 笔者目前只需要开发微信小程序，为了在小程序页面中可以使用 properties behaviors observers 等新功能，已经使用 Component 构造器来构造页面。具体可以参考。如果你也没有多端开发的需求，建议尝试使用，可以得到不错的体验。对于小程序在页面中点击触发 wx.navigateTo 跳转其他页面，中间会有一段时间的空白加载期(对于分包出去的页面，空白期则会更长)，但是这是小程序内部机制，没有办法进行优化。我们只能眼睁睁的等待这段没有意思的空白期过去。当考虑到跳转页面后的第一件事情便是取数逻辑，那么我们是否能够进行优化呢？答案是肯定的。我们没有办法直接在当前页面取得数据之后再进行跳转操作(这样操作更不好)，但是我们却可以利用缓存当前的请求，详情可以参考我之前的博客文章 ——。代码如下:做一份全局的 Map,然后利用 Map 缓存 promise 对象，在跳转之前代码为:而跳转之后的代码也如下所示:如此便可以同时处理取数和页面加载的逻辑，当然，这个对于页面有耦合性，不利于后续的删除与修改。但考虑如果仅仅加在分包跳转之间可能会有不错的效果。想要无侵入式，可以进一步学习研究以及框架，同时考虑到无论是 ToC 还是 ToC 用户，都有可能存在硬件以及网络环境等问题，该优化还是非常值得的。当然微信小程序为了减少冷启动时间，提供了功能。注: 上面的 promiseCache 只作为中转的用途，不作为缓存的用途，如果你考虑添加缓存，可以参考我之前的博客文章——。如果是 pc 端中进行交互，对于数据的 CRUD。例如在详情页面进行了数据的修改和删除，返回列表时候就直接调取之前存储的列表查询条件再次查询即可，而对于移动端这种下拉滚动的设计，就没有办法直接调用之前的查询条件来进行搜索。如果从列表页面进入详情页面后，在详情页面只会进行添加或者修改操作。然后返回列表页面。此时可以提示用户数据已经进行了修改，请用户自行决定是否进行刷新操作。如在编辑页面修改了数据:列表界面:当然了，我们也可以利用 wx.setStorage 或者 getCurrentPage 获取前面的页面 setData 来进行数据通知,以便用户进行页面刷新。如果仅仅只涉及到修改数据的前提下，我们可以选择让用户进行刷新操作，但是如果针对于删除操作而言，如果用户选择不进行刷新，然后用户又不小心点击到了已经被删除的数据，就会发生错误。所以如果有删除的需求，我们最好在返回列表页面前就进行列表的修改，以免造成错误。github 上有很多的 pub/sub 开源库，如果没有什么特定的需求，找到代码量最少的就是这个库了,作者是喜欢开发微型库的大佬,著名的也是出于这位大佬之手。 这里就不做过多的介绍，非常简单。大家可能都能看明白，代码如下(除去 flow 工具的检查):仅仅只有3个方法，on emit以及 off。只要在多个页面导入 生成的 mitt() 函数生成的对象即可(或者直接放入 app.globalData 中也可)。这里mitt可以有多个页面进行绑定事件，如果需求仅仅只涉及到两个页面之间，我们就可以使用 wx.navigateTo 中的 EventChannel (页面间事件信息通道)。可以参考,该方案的利好在于，传递到下一个页面的参数也可以通过 EventChannel 来通知，以便于解决 properties 传递数据不宜过大的问题。注: 一个页面展示很多信息的时候，会造成小程序页面的卡顿以及白屏。小程序官方也有长列表组件。有需求的情况下可以自行研究，这个不在这里详述。如果你觉得这篇文章不错，希望可以给与我一些鼓励，在我的 github 博客下帮忙 star 一下。"}
{"title": "【微信小程序】写一个能自定义尺寸、样式的switch ", "author": "Rolan", "time": "2019-12-24 00:51", "content": "原生的switch不能灵活的修改宽高、样式，很不方便，我这边参考的开关，写了一个可以自定义尺寸样式的switch组件。直接上代码：效果如下图，可以自定义宽高，可以做成方角的这个switch主要的难点就是点击后背景颜色变换的动画，这里用到了css的transition、transform两个属性来实现动画，以及::before和::after两个伪元素。wxml基本结构为：父级view是整个switch容器，会用到::before做背景色切换动画，::after做禁用时的灰色遮罩。内部的一个view是来回切换的白点。未选中时默认class是switch，选中时增加一个class：switch_checked。选中状态到未选中状态背景有一个从中间变大到全部的白色动画，所以需要给父级view设置一个颜色作为背景色。未选中时::before覆盖整个容器，选中时::before设置，这样选中时白色区域就会缩放到最小，再加上transition的实现动画效果。来回移动的白点，未选中时通过定位到左侧，选中时将left设置为100%定位到右侧，但是这样白点会完全移出容器范围，所以还需要加上将白点向左再一定自身宽度的100%，同样加上transition的实现动画效果。最后搭车说一下“:”和“::”，“:”是伪类，“::”是伪元素。按照我的理解：伪类不会在dom中增加节点，只不过是css选择器的一种特殊效果；伪元素会增加节点，flex布局中会影响到其他元素。为了保证兼容性，css3是允许伪元素使用单个冒号。"}
